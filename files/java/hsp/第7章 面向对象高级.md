## 7 面向对象高级

### 7.1 类变量

#### 7.1.1 类变量入门

> 提出问题的主要目的就是让大家思考解决之道，从而引出我要讲的知识点.
> 说：有一群小孩在玩堆雪人,不时有新的小孩加入,请问如何知道现在共有多少人在玩?

~~~java
package com.hspjava.day07_面向对象高级.demo01_类变量和类方法.kn01_引入静态变量;

// 引入静态变量:有一群小孩在玩堆雪人,不时有新的小孩加入,请问如何知道现在共有多少人在玩?
public class ChildGame {
    public static void main(String[] args) {

        // int count = 0;

        Child child1 = new Child("1");
        child1.join();
        // count++
        child1.count++;

        Child child2 = new Child("2");
        child2.join();
        // count++
        child2.count++;

        // 类变量,可以通过类名来访问
        System.out.println("共有" + Child.count + "加入了游戏"); //2

        // 此时,看下各个对象的count情况
        System.out.println(child1.count); // 2
        System.out.println(child2.count); // 2
    }
}


class Child{

    private String name;

    // 定义一个类变量(静态变量) 表示计数
    /*
        该变量的最大特点就是会被Child类的所有对象实例共享
     */
    public static int count = 0;

    public Child(String name){
        this.name = name;
    }

    public void join(){
        System.out.println(name + "加入了游戏");
    }
}
~~~

#### 7.1.2 类变量内存分析

> 1.static变量是同一个类所有对象共享的
>
> 2.static变量是在类加载的时候就生成了

#### 7.1.3 类变量及细节

> 1.什么是类变量?
>
> 类变量也叫静态变量/静态属性,是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量
>
> 2.如何定义类变量?
>
> 定义语法:
> 访问修饰符 static 数据类型 变量名; [推荐]
> static 访问修饰符 数据类型 变量名;
>
> 3.如何访问类变量?
>
> 类名.类变量名 [推荐]
> 或者
> 对象名.类变量名 [<font color='yellow'> 静态变量的访问修饰符的访问权限和范围 和 普通属性是一样的</font>]
>
> 4.什么时候需要用到类变量?
>
> 当我们需要让某个类的所有对象家都共享一个变量时,就可以考虑使用类变量
>
> 5.类变量与实例变量(普通属性)的区别?
>
> 类变量是该类的所有对象共享的,而实例变量时每个对象独享的
>
> 6.加上static称为类变量/静态变量;  不加上static称为 普通属性/普通成员变量/非静态属性/非静态成员变量/非静态变量
>
> 7.类变量可以通过类名.类变量名 或者 对象名.类变量名访问,推荐第一种并且满足访问修饰符的访问权限和范围
>
> 8.实例变量不能通过类名.变量名访问
>
> 9.类变量是在类加载的时候就初始化了,也就是说,即使你没有创建对象,只要类加载,就可以使用类变量
>
> 10.类变量的生命周期是随着类的加载开始,随着类消亡而消亡

~~~java
/*说明:
    类变量是随着类加载而创建的,所以即使没有创建对象实例也是可以访问的
*/
public class StaticVariable {
    public static void main(String[] args) {

        // 类名.类变量名
        System.out.println(A.name);

        // 那么使用对象来访问可以吗? 可以,但是要注意访问修饰符的使用范围
        A a = new A();
        System.out.println(a.name);

    }
}

class A{

    // 类变量的访问,必须也要遵守访问权限
    public static String name = "txl";
}

~~~

~~~java
public class StaticVariableDetail {
    public static void main(String[] args) {

        // 5. 实例变量不能通过类名.变量名访问
        // System.out.println(B.n1);

        B b = new B();
        System.out.println(b.n1);

        // 6.类变量是在类加载的时候就初始化了,即使你没有创建对象,只要类加载,就可以使用类变量
        System.out.println(C.name);

    }
}

class B{

    public int n1 = 100;

}


class C{
    public static String name = "北京";
}
~~~

#### 7.1.4 类方法基本介绍

> 1.类方法的基本介绍
>
> 类方法也叫静态方法;
>
> 格式:
> 访问修饰符 static 数据返回类型 方法名(){ }  [推荐]
>
> static 访问修饰符 数据返回类型 方法名(){ }
>
> 2.类方法的调用
>
> 类名.类方法名  或者 对象.类方法名  [同样需要满足访问修饰符的权限和范围]
>
> 3.类方法的使用场景
>
> 当方法中不涉及到任何对象相关的成员,则可以将方法设计成静态方法,提高开发效率--工具类比较多(Math)
>
> 实际开发中,往往将一些通用的方法,设计成静态方法,这样我们不需要创建对象就可以使用了,比如打印一维数组,冒泡排序,完成某个计算任务等
>
> 4.类方法的使用细节
>
> 1).类方法和普通方法都是随着类的加载而加载,将结构信息存贮在方法区: <font color='cyan'> 类方法中无this的参数</font>;普通方法中含有this的参数
>
> 2).类方法可以通过类名调用,也可以通过对象名调用
>
> 3).普通方法和对象有关,需要通过对象名调用
>
> 4).类方法中不允许使用和对象有关的关键字,比如this和super,普通方法(成员方法)可以
>
> 5).<font color='cyan'> 类方法中 只能访问 静态变量和静态方法</font>
>
> 6).普通方法既可以访问非静态成员 也可以访问非静态成员
>
> 结论: <font color='cyan'> 静态方法,只能访问静态的成员,静态的方法;
> 非静态方法可以访问非静态方法/成员 和静态成员/方法且遵守访问权限</font>
>
> 

~~~java
public class StaticMethod {
    public static void main(String[] args) {
        //创建2个学生对象,累计学费
        Stu stu1 = new Stu("tom");
        stu1.payFee(100);
        Stu.payFee(100);

        Stu stu2 = new Stu("marry");
        stu2.payFee(200);
        Stu.payFee(200);

        // 输出当前收到的总学费
        Stu.showFee();

        // 静态方法的使用场景:不创建实例,也可以调用某个方法(即当我做工具来使用),这时通过静态方法实现
        // 工具类
        System.out.println("9的开方: " + Math.sqrt(9));
        // 通用的方法
        System.out.println(MyTools.sum(10, 20));
    }
}


class Stu{

    // 普通属性
    private String name;
    // 静态变量,累计学生的学费
    private static double fee;

    public Stu(String name) {
        this.name = name;
    }
    /*
    * 说明:
    * 1.当方法使用了static修饰后,该方法就是静态方法
    * 2.静态方法就可以访问静态变量
    * */
    // 累加学费
    public static void payFee(double fee){
        Stu.fee += fee;
    }
    // 显示总学费
    public static void showFee(){
        System.out.println("总收到的学费: " + Stu.fee);
    }
}

// 开发自己的工具类时,也可以做成静态方法,方便调用
class MyTools{

    // 求和
    public static double sum(double n1, double n2){
        return n1 + n2;
    }
}
~~~

~~~java
public class StaticMethodDetails {
    public static void main(String[] args) {

        D.hi();

        // 非静态方法不能通过类名调用
        // D.say();  需要先创建对象再调用


    }
}

class D{
    private int n1 = 100;

    private static int n2 =200;

    public void say(){ //普通方法可以访问非静态成员,静态成员
        hi();
        hello();
        n2 = 400;
        n1 = 100;
    }


    public static void hi(){

        // 类方法中不允许使用和对象有关的关键字,比如this和super,普通方法(成员方法)可以
        // this.n1;


        // 类方法中 只能访问 静态变量和静态方法
        hello();
        n2 = 300;
        System.out.println(D.n2);
        // this.n2 = 300;
        // this.n1 = 400;

        // 不能从静态上下文中引用非静态方法“say()”
        // say();
        // n1 = 10;
        new D().say();
        new D().n1 = 200;

    }

    public static void hello(){

    }
}

~~~

#### 7.1.5 练习题

~~~java
// 请先看语法是否有错误,修改后输出
class Person{
    private int id;
    private static int total = 0;
    public static int getTotalPerson(){
        id++; // 此处有问题,静态方法访问非静态属性,需注释
        return total;
    }
    public Person(){
        total++;
        id = total;
    }
}

public class TestPerson{
    public static void main(String[] args){
        System.out.println(Person.getTotalPerson()); // 0
        Person person = new Person();
        System.out.println(Person.getTotalPerson()); // 1
    }
}
~~~

~~~java
// 请先看语法是否有错误,修改输出total的值
class Person{
    private int id;
    private static int total = 0;
    public static void setTotalPerson(int total){
        this.total = total; // 此处有问题,不能有this
        Person.total = total;
    }
    public Person(){
        total++;
        id = total;
    }
}

public class TestPerson{
    public static void main(String[] args){
        Person.setTotalPerson(3); // total = 3
        new Person(); // total = 4
    }
}
~~~

### 7.2 main方法

> 1.main()是由java虚拟机调用,所以该方法的使用权限是public
>
> 2.java虚拟机在执行main()方法时不必创建对象,所以该方法必须是static
>
> 3.main方法接收String类型的数组,该数组保存执行java命令时传递给所运行类的参数
>
> 4.java 执行程序 参数1 参数2 参数3
>
> 5.在main()中,我们可以直接调用main方法所在的类的静态方法和静态属性;但是不能直接访问该类的非静态属性,必须创建该类的一个实例对象的时候,才能通过这个对象去访问类中的非静态成员

~~~java
public class Main01 {

    private static String str = "hspedu";

    private String str1 = "ss";

    public static void hi(){
        System.out.println("hi...");
    }

    public void show(){
        System.out.println("show...");
    }


    public static void main(String[] args) {

        // 静态方法可以访问本类的静态属性
        System.out.println(str);
        // 静态方法可以访问本类的静态方法
        hi();
        // 静态方法不可以访问本类的非静态属性/方法
        // show();
        // System.out.println(str1);

        // 想要访问非静态成员就必须创建类的实例
        Main01 main01 = new Main01();
        System.out.println(main01.str1);
        main01.show();

    }
}
~~~

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220319162809254.png" alt="image-20220319162809254" style="zoom: 33%;" />

### 7.3 代码块

#### 7.3.1 代码块介绍

> 1.代码块又称为初始化块,属于类中的成员[即 是类的一部分].类似于方法,将逻辑语句封装在方法体中,通过{}包裹;但是代码块又和方法不同,没有方法名,没有返回,没有参数,只有方法体,而且<font color='cyan'> 不通过对象或者类显式的调用,而是在加载类的时候,或者创建对象的时候隐式调用</font>
>
> 2.基本语法:
>
> <font color='cyan'>[修饰符]{ 代码};</font>
>
> 1).修饰符可选,<font color='cyan'> 修饰符只能为static</font>
>
> 2).分类:静态代码块, 非静态代码块/代码块
>
> 3).逻辑语句可以为任何逻辑语句(输入 输出 方法调用 循环 判断等))
>
> 4). ';' 可以写,也可以不写
>
> 3.代码块好处
>
> 1) 相当于另外一种形式的构造器(堆构造器的补充机制),可以做初始化的操作
>
> 2) 如果多个构造器中都有重复语句,可以抽取到初始化块中,提高代码的重用性--应用场景

~~~java
public class CodeBlock01 {
    public static void main(String[] args) {

        Movie movie = new Movie("你好,李焕英");
        /*
                电影屏幕打开
                广告打开
                电影正式开始
                Movie(name)
            可以看出 代码块的调用顺序优先于构造器
         */
    }
}


class Movie{

    private String name;
    private double price;
    private String director;

    // 3个构造器 ->重载
    /*
        下面的三个构造器都有相同的语句,代码繁琐
        可以把相同的语句,放入到代码块中即可;
        当我们不管调用哪个构造器创建对象,都会先调用代码块的内容
        可以看出 代码块的调用顺序优先于构造器
     */
    {
        System.out.println("电影屏幕打开");
        System.out.println("广告打开");
        System.out.println("电影正式开始");
    }
    public Movie(String name) {
        // System.out.println("电影屏幕打开");
        // System.out.println("广告打开");
        // System.out.println("电影正式开始");
        System.out.println("Movie(name)");
        this.name = name;
    }

    public Movie(String name, double price) {
        // System.out.println("电影屏幕打开");
        // System.out.println("广告打开");
        // System.out.println("电影正式开始");
        this.name = name;
        this.price = price;
    }

    public Movie(String name, double price, String director) {
        // System.out.println("电影屏幕打开");
        // System.out.println("广告打开");
        // System.out.println("电影正式开始");
        this.name = name;
        this.price = price;
        this.director = director;
    }
}

~~~

#### 7.3.2 代码块细节

> 1.static代码块也叫静态代码块,作用就是对类进行初始化,而且他随着类的加载而执行,并且<font color='cyan'> 只会执行一次</font>;如果是普通代码块,每创建一个对象就执行
>
> 2.<font color='cyan'> 类什么时候被加载?</font></
>
> ①创建对象实例时(new)
>
> ②创建子类对象实例时,父类也会被加载
>
> ③使用类的静态成员(静态属性/方法)
>
> 3.<font color='cyan'> 普通的代码块,在创建对象实例的时候,会被隐式的调用,被创建一次就会调用一次,如果只是使用类的静态成员时,普通代码块并不会执行</font>
>
> 小结:
>
> static代码块是类加载时执行只会执行一次
>
> 普通代码块是在创建对象时调用,创建一次调用一次
>
> 类加载的三种情况需要记住

~~~java
public class CodeBlockDetail01 {
    public static void main(String[] args) {

        // 类什么时候被加载?
        // 1.创建对象实例
        AA aa = new AA(); // AA的静态代码块被执行
        System.out.println("创建对象实例------");
        // 2.创建子类对象,父类也会被加载,而且,父类会先加载子类后加载
        BB bb = new BB(); // BB的静态代码块被执行
        System.out.println("创建子类实例对象-----");
        /*
            为什么不输出父类的静态代码块呢? 因为静态代码块只会执行一次
         */
        // 3.使用类的静态成员时
        Cat.n1 = 1000; // Animal的静态代码块被执行 Cat的静态代码块被执行
        System.out.println("使用类的静态成员-----");

        // 静态代码块只会执行一次
        CC cc = new CC();
        CC cc1 = new CC(); // CC的静态代码块被执行

        // 普通代码块在创建对象时, 会被隐式调用
        // 被创建一次,就会调用一次
        // 如果只是使用类的静态成员时,普通代码块并不会被执行
        DD dd = new DD(); // DD的普通代码块被执行
        DD dd1 = new DD(); // DD的普通代码块被执行
        DD.n2 = 100; // 调用类的静态成员,普通代码块并没有输出
        /*
            结论: 普通代码块,在new对象时被调用,而且是没创建一个对象,就调用一次
            可以简单理解: 普通代码块是构造器的补充
         */
    }
}

class AA{

    // 静态代码块
    static {
        System.out.println("AA的静态代码块被执行");
    }
}

class BB extends AA{

    // 静态代码块
    static {
        System.out.println("BB的静态代码块被执行");
    }
}

class Animal{

    static {
        System.out.println("Animal的静态代码块被执行");
    }
}

class Cat extends Animal{

    public static int n1 = 999;
    static {
        System.out.println("Cat的静态代码块被执行");
    }
}

class CC {

    static {
        System.out.println("CC的静态代码块被执行");
    }
}

class DD {

    public static int n2 = 10;
    {
        System.out.println("DD的普通代码块被执行");
    }
}
~~~

> 4.<font color='cyan'> 创建一个对象时,在一个类的调用顺序(重点)</font>
>
> ①调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样,如果有多个静态代码块和静态属性变量初始化,则按照他们定义的顺序执行)
>
> ②调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性的优先级一样,如果有多个普通代码块和多个普通属性初始化,则按照定义的顺序调用)
>
> ③调用构造方法

~~~java
public class CodeBlockDetail02 {
    public static void main(String[] args) {
        A a = new A();
        /*
            输出顺序:调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样,如果有多个静态代码块和静态属性变量初始化,则按照他们定义的顺序执行)
            getN1被调用
            A的静态代码块
         */
        // 增加普通属性之后的输出顺序?调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性的优先级一样,如果有多个普通代码块和多个普通属性初始化,则按照定义的顺序调用)
        /*
            getN1被调用
            A的静态代码块
            getN2被调用
            A的普通代码块
         */
        // 增加构造器之后的输出顺序
        /*
            getN1被调用
            A的静态代码块
            getN2被调用
            A的普通代码块
            A的无参构造器被调用
         */

    }
}

class A{
    // 静态属性的初始化
    private static int n1 = getN1();
    // 静态代码块
    static {
        System.out.println("A的静态代码块");
    }
    // 静态方法
    public static int getN1(){
        System.out.println("getN1被调用");
        return 100;
    }

    // 普通属性初始化
    private int n2 = getN2();
    // 普通代码块
    {
        System.out.println("A的普通代码块");
    }
    // 普通方法
    public int getN2() {
        System.out.println("getN2被调用");
        return 200;
    }

    // 构造器
    public A(){
        System.out.println("A的无参构造器被调用");
    }
}
~~~

> 5.构造器的最前面其实隐含了super() 和调用普通代码块;静态相关的代码块,属性初始化,在类加载的时候就执行完毕,因此优先于构造器和普通代码块执行

~~~java
class A{
    public A(){
        // 1.隐藏了super()
        super();
        // 2.调用普通代码块
        System.out.println();
    }
}
~~~

~~~java
public class CodeBlockDetail03 {
    public static void main(String[] args) {
        BBB bbb = new BBB(); // AAA的普通代码块 AAA的无参构造器 BBB的普通代码块 BBB的无参构造器
    }
}

class AAA{
    {
        System.out.println("AAA的普通代码块");
    }
    public AAA() {
        System.out.println("AAA的无参构造器");
    }
}

class BBB extends AAA{

    {
        System.out.println("BBB的普通代码块");
    }

    public BBB(){
        // 1.super()
        // 2.调用本类的代码块
        System.out.println("BBB的无参构造器");
    }

}
~~~

> 6.我们看一下创建一个子类对象时(继承关系),他们的静态代码块, 静态属性初始化, 普通代码块, 普通属性初始化,构造方法的调用顺序如下:
>
> ①父类的静态代码块和静态属性(优先级一样,按照定义的顺序执行)
>
> ②子类的静态代码块和静态属性(优先级一样,按照定义的顺序执行)
>
> ③父类的普通代码块和普通属性初始化(优先级一样,按照定义的顺序执行)
>
> ④父类的构造方法
>
> ⑤子类的普通代码块和普通属性初始化(优先级一样,按照定义的顺序执行)
>
> ⑥子类的构造方法
>
> 7.静态代码块只能调用静态成员,普通代码块可以调用任意成员

~~~java
public class CodeBlockDetail04 {
    public static void main(String[] args) {
        B01 b01 = new B01();// 先进行类加载,再创建对象
        /*
                getVal01
                A02 的一个静态代码块..
                getVal03
                B02 的一个静态代码块..
                A02 的第一个普通代码块..
                getVal02
                A02 的构造器
                getVal04
                B02 的第一个普通代码块..
                B02 的构造器
         */

        C01 c01 = new C01();
    }
}


class A01{
    private static int n1 = getVal01();
    static {
        System.out.println("A02 的一个静态代码块..");
    }
    {
        System.out.println("A02 的第一个普通代码块..");
    }
    public int n3 = getVal02();//普通属性的初始化
    public static int getVal01() {
        System.out.println("getVal01");
        return 10;
    }
    public int getVal02() {
        System.out.println("getVal02");
        return 10;
    }
    public A01() {//构造器
    //隐藏
    //super()
    //普通代码和普通属性的初始化......
        System.out.println("A02 的构造器");
    }
}

class B01 extends A01{
    private static int n3 = getVal03();
    static {
        System.out.println("B02 的一个静态代码块..");
    }
    public int n5 = getVal04();
    {
        System.out.println("B02 的第一个普通代码块..");
    }
    public static int getVal03() {
        System.out.println("getVal03");
        return 10;
    }
    public int getVal04() {
        System.out.println("getVal04");
        return 10;
    }
    //一定要慢慢的去品..
    public B01() {//构造器
        //隐藏了
        //super()
        //普通代码块和普通属性的初始化...
        System.out.println("B02 的构造器");
    }
}

class C01{
    private int n1 = 100;
    private static int n2 = 200;
    private void f1(){
        System.out.println("普通方法f1");
    }
    private static void f2(){
        System.out.println("静态方法f2");
    }

    static {
//        System.out.println(n1);
        System.out.println(n2);
//        f1();
        f2();
    };

    {
        System.out.println(n1);
        System.out.println(n2);
        f1();
        f2();
    }
}

~~~

#### 7.3.3 练习

~~~java
题 1：下面的代码输出什么？1min
class Person {
 public static int total;//静态变量
 static {//静态代码块
    total = 100;
    System.out.println("in static block!");//(1)
    }
}
public class Test {
    public static void main(String[] args) {
        System.out.println("total = "+ Person.total); //100
        System.out.println("total = "+ Person.total); //100
    }
}
~~~

~~~java
题 2：下面的代码输出什么？CodeBlockExercise02.java
class Sample{
 Sample(String s){
  System.out.println(s);
 }
 Sample(){
  System.out.println(“Sample 默认构造函数被调用");
 }
}

class Test{
 Sample sam1=new Sample("sam1 成员初始化");//
 static Sample sam=new Sample("静态成员 sam 初始化 ");//
 static{
  System.out.println("static 块执行");//
  if(sam==null)System.out.println("sam is null");
 }
 Test(){
 System.out.println("Test 默认构造函数被调用");//
 }
}
//主方法
public static void main(String str[]){
 Test a=new Test();//无参构造器
}
//运行结果
1. 静态成员 sam 初始化
2. static 块执行
3. sam1 成员初始化
4. Test 默认构造函数被调用
~~~

### 7.4 单例设计模式

> 1.什么是单例设计模式?
>
> 单例(单个的实例),所谓类的单例设计模式,就是采取一定的方法保证在整个的软件系统中,<font color='cyan'>对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法</font>
>
> 2.单例模式的两种方式?
>
> 1)饿汉式 2)懒汉式
>
> 3.饿汉式实现步骤:
>
> 1) 构造方法私有化
>
> 2) 类的内部创建对象
>
> 3) 向外暴露一个公共的静态方法

~~~java
// 饿汉式
public class SingleMode01 {
    public static void main(String[] args) {

//        GirlFriend girlFriend1 = new GirlFriend("小花");
//        GirlFriend girlFriend2 = new GirlFriend("小红");
        // 说明创建了两个对象,就不是单例
        
        // 通过方法获取对象
        GirlFriend girlFriend = GirlFriend.getInstance();
        System.out.println(girlFriend);
        
        // 再次获取
        GirlFriend girlFriend1 = GirlFriend.getInstance();
        System.out.println(girlFriend1);
        // 看出两个是同一个对象,static只会初始化一次
        System.out.println(girlFriend == girlFriend1);

    }
}

// 类 GirlFriend,要求只能有一个女盆友
class GirlFriend {

    /*
        如何保证只能创建一个GirlFriend对象?
        饿汉式: 只要类加载就已创建了对象,这样就会导致对象有时不需要就被创建
        1.将构造器私有化
        2.类的内部创建对象
        3.再提供一个公共的静态方法
     */
    private String name;

    private GirlFriend(String name) {
        this.name = name;
    }
    // 使用static才能被使用
    private static GirlFriend girlFriend = new GirlFriend("瑶瑶");
    public static GirlFriend getInstance(){
        return girlFriend; // 此时需要将girlFriend对象静态实现,才能直接引用
    }

    //重写toString(),返回属性信息
    @Override
    public String toString() {
        return "GirlFriend{" +
                "name='" + name + '\'' +
                '}';
    }
}
~~~

> 4.懒汉式:
>
> 1) 构造器私有化 
> ​ 2) 定义一个静态属性对象
> ​ 3) 提供一个公共的静态的方法,可以返回一个Cat对象

~~~java
// 懒汉式
public class SingleMode02 {
    public static void main(String[] args) {
        // 此时调用静态属性,并没有创建对象
        System.out.println(Cat.n1); // 999

        // 什么时候才会创建对象呢?调用方法
        Cat cat = Cat.getInstance("小猫");
        System.out.println(cat);

        // 再次调用getInstance()呢?
        Cat cat1 = Cat.getInstance("小狗");
        System.out.println(cat1);
        /*
            构造器被调用
            Cat{name='小猫'}
            Cat{name='小猫'}
            可以看出当第一次创建cat对象后,cat == null已经不满足,此时只会创建一次实例
         */
    }
}

//希望在程序运行过程中只能创建一个对象
/*
    单例:
    1.构造器私有化
    2.定义一个静态属性对象
    3.提供一个公共的静态的方法,可以返回一个Cat对象
    4.懒汉式:只有当用户使用getInstance(),才会返回cat对象,后面再次调用时,会返回上次创建的cat对象,从而保证了单例
 */
class Cat{
    private String name;
    public static int n1 = 999;
    private Cat(String name) {
        System.out.println("构造器被调用");
        this.name = name;
    }
    private static Cat cat;
    public static Cat getInstance(String name){
        if (cat == null){ // 如果还没有创建Cat对象
            cat = new Cat(name);
        }
        return cat;
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                '}';
    }
}
~~~

> 5.饿汉式VS懒汉式
>
> ①二者最主要的区别在于<font color='cyan'> 创建对象的时机不同</font>:饿汉式是在类加载的时候创建了实例对象,而懒汉式是在使用时才创建
>
> ②饿汉式不存在线程安全问题,懒汉式存在线程安全问题
>
> ③饿汉式存在浪费资源的可能,因为如果一个实例对象都没有使用,那么创建的对象就浪费了,懒汉式是使用时才创建,就不会存在这个问题
>
> ④java.lang.Runtime就是经典的返利模式

### 7.5 final关键字

#### 7.5.1 final基本语法

> 1.final基本介绍
>
> final可以修饰类 属性 方法 和 局部变量
>
> ①当不希望类被继承时,可以使用final修饰
>
> ②当不希望父类的某个方法被子类覆盖/重写时,可以使用final修饰
>
> ③当不希望类的某个属性被修改时,可以使用final修饰
>
> ④当不希望某个局部变量被修改,可以使用final修饰

~~~java
public class Final01 {
    public static void main(String[] args) {
//        new C().TAX_RATE = 0.09; // 无法将值赋给 final 变量 'TAX_RATE'
    }
}
// 要求A不能被其他类继承
final class A {

}

//class B extends A {} // 无法从final 'com.hspjava.day07_面向对象高级.demo05_final.A' 继承

class C{
    // 要求hi()不能被子类重写
    public final void hi(){
        // 要求局部变量不能改 局部常量
        final double NUMBER = 0.01;
//        NUMBER = 0.09; // 无法将值赋给 final 变量 'NUMBER'
    }

    // 要求属性不能修改
    public final double TAX_RATE = 0.08;
}

class D extends  C{

//    @Override
//    public void hi() { // 'hi()' 无法重写 'com.hspjava.day07_面向对象高级.demo05_final.C' 中的 'hi()'；重写的方法为 final
//        super.hi();
//    }
}
~~~

#### 7.5.2 final注意事项

> 1.final修饰的属性又叫常量,一般用XX_XX_XX来命名
>
> 2.final修饰的属性在定义时,必须赋初值,并且不能修改,赋值可以在如下位置:
>
> ①定义时: public final double TAX_RATE = 0.08;
>
> ②在构造器中
>
> ③在代码块中
>
> 3.如果final修饰的属性是静态的,则初始化的位置只能是:
>
> ①定义时
>
> ②在静态代码块下 不能再构造器中赋值
>
> 4.final类不能继承,但是可以实例化对象
>
> 5.如果类不是final类,但是含有final方法,则该方法虽然不能重写但是可以被继承

~~~java
public class FinalDetail01 {
    public static void main(String[] args) {
        B01 b01 = new B01();

        new D01().cal();
    }
}

class A01{
    // final修饰的属性在定义时,必须赋初值,并且不能修改
    // 1.直接定义
    public final double TAX_RATE = 0.08;
    // 2.构造器中
    public final double TAX_RATE2;
    public A01() {
        TAX_RATE2 = 0.07;
    }
    // 3.代码块
    public final double TAX_RATE3;
    {
      TAX_RATE3 = 0.09;
    }

    // 如果final修饰的属性是静态的,则初始化的位置只能是定义与静态代码块中
    public static final double NUM = 0.01; // 直接定义
    // 静态代码块
    public static final double NUM1;
    static {
        NUM1 = 0.02;
    }

    // 构造器呢? 因为构造器是创建对象之后.static不需要创建对象
//    public static final double NUM2;
//    public A01(String name){
//        NUM2 = 0.03;
//    }
}
// final类不能继承,但是可以实例化对象 main方法中证明可以实例化
final class B01{

}

// 如果类不是final类,但是含有final方法,则该方法虽然不能重写但是可以被继承

class C01 {

    public final void cal(){
        System.out.println("final");
    }
}
// 能继承这个cal方法吗? 在main方法中调用,发现可以继承该final方法
class D01 extends C01{

}
~~~

> 6.一般来说,如果一个类是final,就没有必要再将方法修饰成final方法
>
> 7.final不能修饰构造器
>
> 8.final和static往往搭配使用,效率更高,不会导致类加载
>
> 9.包装类(Integer, Double, Float, Boolean等都是final,String也是final类

~~~java
public class FinalDetail02 {
    public static void main(String[] args) {
        System.out.println(B02.NUM);
        /*
            只会打印100
            去掉final 之后,就会打印
            B02静态代码块被执行
            100
         */
    }
}

// 一个类是final,就没有必要再将方法修饰成final方法
final class A02{
    public final void f1(){ // 类已经无法继承,方法就更不会被重写了

    }
}

// final和static往往搭配使用,效率更高,不会导致类加载 --- main方法中可以看出 底层的内部优化,不会加载类
class B02{
    public final static int NUM = 100;
    static {
        System.out.println("B02静态代码块被执行");
    }
}
~~~

#### 7.5.3 基本练习

~~~java
// 请写出程序,计算圆形的面积,要求圆周率为3.14,赋值的3个位置都写一下
public class FinalExercise01 {
    public static void main(String[] args) {
        Circle circle = new Circle();
        circle.setRadius(2);
        System.out.println(circle.Area());
        System.out.println(circle.Area1());
        System.out.println(circle.Area2());
    }
}

class Circle{

    private double radius;
    // 1.直接定义
    public static final double PI = 3.14;

    public double Area(){
        return getRadius() * getRadius() * PI;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    // 2.构造器
    public  final double PI1;
    public Circle(){
        PI1 = 3.14;
    }
    public double Area1(){
        return getRadius() * getRadius() * PI1;
    }

    // 代码块中
    public  final double PI2;
    {
        PI2 = 3.14;
    }
    public double Area2(){
        return getRadius() * getRadius() * PI2;
    }
}
~~~

~~~java
public class SomeThing{
    public int addOne (final int x){  // final 可以为形参
        ++x; // 错误,不能修改final的值,无法将值赋给 final 变量 'x'
        retrun x+1; //正确,不影响x的值
    }
}
~~~

### 7.6 抽象类

#### 7.6.1 抽象类引入

> 当父类的某些方法,需要声明,但是又不确定如何实现,就可以将其声明为抽象方法,那么这个类就是抽象类
>
> 1.用abstract关键字来修饰一个类时,这个类就是抽象类
>
> 访问修饰符 abstract 类名{ }
>
> 2.用abstract关键字来修饰一个方法时,这个方法就是抽象方法
>
> 访问修饰符 abstract 返回值类型 方法名(形参); // 没有方法体
>
> 3.抽象类的价值更多在于设计,是设计好之后让子类继承并实现抽象类
>
> 4.抽象类,在框架和设计模式中使用的比较多些

~~~java
public class Abstract01 {
}

abstract class Animal{
    
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat1(){
        System.out.println("这是一个动物,但是不知道吃什么");
    }
    /*
        这里的eat()的实现有什么意义呢?
        其实没有意义,父类方法不确定性
        此时,考虑将该方法设计为抽象方法(abstract)
        所谓抽象方法就是没有实现的方法,就是指没有方法体的方法
        当一个类中存在抽象方法时,就需要将该类声明为抽象类
        一般来说,抽象类会被继承,由其子类来实现这个抽象的方法
     */
    public abstract void eat(); // 声明抽象方法
}
~~~

#### 7.6.2 抽象类细节

> 1.抽象类不能实例化
>
> 2.抽象类不一定要包含abstract方法,也就是说抽象类可以没有抽象方法
>
> 3.一旦类包含了抽象方法,则这个类就必须声明为abstract
>
> 4.abstract只能修饰类和方法,不能修饰属性和其他的

~~~java
public class AbstractDetail01 {
    public static void main(String[] args) {
          // 抽象类不能实例化
//        A01 a01 = new A01(); // A01' 为 abstract；无法实例化
    }
}

abstract class A01{

    // 抽象类不一定要包含abstract方法
    public void f1(){
    }
    // 类包含了抽象方法,则这个类就必须声明为abstract
    public abstract void f2();

    //abstract只能修饰类和方法,不能修饰属性和其他的
//    public abstract int num = 5; // 此处不允许使用修饰符 'abstract'
}
~~~

> 5.抽象类可以有任意成员(非抽象方法,构造器,静态属性等等) -- 抽象类本质还是类
>
> 6.抽象方法不能有主体,即不能实现
>
> 7.如果一个类继承了抽象类,则它必须实现抽象类的所有抽象方法,除非他自己也声明为abstract类
>
> 8.抽象方法不能使用private final 和static类修饰,因为这些关键字都是和重写违背的

#### 7.6.3 抽象类练习

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220320194845297.png" alt="image-20220320194845297" style="zoom:50%;" />

~~~java
public class AbstractExercise {
    public static void main(String[] args) {
        CommonEmployee commonEmployee = new CommonEmployee("张三","002",500);
        commonEmployee.work();

        Manager manager = new Manager("李四", "001", 1000, 1000);
        manager.work();
    }
}

abstract class Employee {

    private String name;
    private String id;
    private double salary;

    public Employee(String name, String id, double salary) {
        this.name = name;
        this.id = id;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public abstract void work();
}

class Manager extends Employee{

    private double bonus;

    public Manager(String name, String id, double salary, double bonus) {
        super(name, id, salary);
        this.bonus = bonus;
    }

    public double getBonus() {
        return bonus;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    @Override
    public void work() {
        System.out.println("经理" + getName() + "工作中...");
    }
}

class CommonEmployee extends Employee{

    public CommonEmployee(String name, String id, double salary) {
        super(name, id, salary);
    }

    @Override
    public void work() {
        System.out.println("普通员工" + getName() + "工作中...");
    }
}
~~~

#### 7.6.4 抽象类最佳实践-模板设计模式

> 1) 有多个类,完成不同的任务
>
> 2) 要求统计得到各自完成任务的时间
>
> 设计一个抽象类Template,(运用动态绑定机制)实现:
>
> ①编写calculateTime(),计算损耗时时间
>
> ②编写抽象方法code()
> ③编写子类继承抽象类Template,实现code()

~~~java
public class AbstractTemplate01 {
    public static void main(String[] args) {
        A03 a03 = new A03();
        a03.job();

        B03 b03 = new B03();
        b03.job();
    }
}


class A03{
    // 计算1-10000000的和
    public void job(){

        // 得到开始的时间
        long startTime = System.currentTimeMillis();
        int num = 0;
        for (int i = 0; i < 10000000; i++) {
            num += i;
        }
        // 得到结束的时间
        long endTime = System.currentTimeMillis();
        System.out.println("执行的时间: " + (endTime -startTime));
    }
}


class B03{
    // 计算1-80000000的和
    public void job(){

        // 得到开始的时间
        long startTime = System.currentTimeMillis();
        int num = 0;
        for (int i = 0; i < 80000000; i++) {
            num += i;
        }
        // 得到结束的时间
        long endTime = System.currentTimeMillis();
        System.out.println("执行的时间: " + (endTime -startTime));
    }

//    public void job1(){
//        long startTime = System.currentTimeMillis();
//        int num = 0;
//        for (int i = 0; i < 100000000; i++) {
//            num += i;
//        }
//        // 得到结束的时间
//        long endTime = System.currentTimeMillis();
//        System.out.println("执行的时间: " + (endTime -startTime));
//    }
}
~~~

~~~java
public class AbstractTemplate02 {
    public static void main(String[] args) {
        A04 a04 = new A04();
        a04.calculateTime();

        B04 b04 = new B04();
        b04.calculateTime();
    }
}


// 思考如何进行改良? 1.将共有的任务提取出来,缺陷:扩展能力太弱
class A04 {
    public void calculateTime(){
        // 得到开始的时间
        long startTime = System.currentTimeMillis();
        job();
        // 得到结束的时间
        long endTime = System.currentTimeMillis();
        System.out.println("执行的时间: " + (endTime -startTime));
    }

    // 计算1-10000000的和
    public void job(){
        int num = 0;
        for (int i = 0; i < 10000000; i++) {
            num += i;
        }
    }
}


class B04 {
    public void calculateTime(){
        // 得到开始的时间
        long startTime = System.currentTimeMillis();
        job();
        // 得到结束的时间
        long endTime = System.currentTimeMillis();
        System.out.println("执行的时间: " + (endTime -startTime));
    }

    // 计算1-80000000的和
    public void job() {
        int num = 0;
        for (int i = 0; i < 80000000; i++) {
            num += i;
        }
    }
}
~~~

~~~java
// 模板设计 进行优化
/*
      设计一个抽象类Template,实现:
        ①编写calculateTime(),计算损耗时时间
        ②编写抽象方法code()
        ③编写子类继承抽象类Template,实现code()
 */
public class AbstractTemplate03 {
    public static void main(String[] args) {
        Template a05 = new A05();
        a05.calculateTime();
    }
}

/**
 *  抽象类--模板设计模式
 */
abstract class Template {

    public abstract void job(); // 抽象方法

    //    计算损耗时时间
    public void calculateTime() { // 非抽象方法调用抽象方法
        // 得到开始的时间
        long startTime = System.currentTimeMillis();
        job(); //进行动态绑定机制
        // 得到结束的时间
        long endTime = System.currentTimeMillis();
        System.out.println("执行的时间: " + (endTime - startTime));
    }

}

class A05 extends Template {
    // 计算1-10000000的和
    public void job() {
        int num = 0;
        for (int i = 0; i < 10000000; i++) {
            num += i;
        }

    }
}


class B05 extends Template {
    // 计算1-80000000的和
    public void job() {

        int num = 0;
        for (int i = 0; i < 80000000; i++) {
            num += i;
        }
    }
}
~~~

### 7.7 接口

#### 7.7.1 接口入门

> 实现手机,照相机通过usb链接至电脑这样的现实问题

 ~~~java
public interface USB {

    // 规定接口的相关方法--规范
    public void start();
    public void stop();
}
 ~~~

~~~java
public class Phone implements USB { // 实现接口,就是把接口的方法实现
    @Override
    public void start() {
        System.out.println("手机开始工作");
    }

    @Override
    public void stop() {
        System.out.println("手机停止工作");
    }
}
~~~

~~~java
public class Camera implements USB{ // 实现接口

    @Override
    public void start() {
        System.out.println("相机开始工作");
    }

    @Override
    public void stop() {
        System.out.println("相机停止工作");
    }
}
~~~

~~~java
public class Computer {
    //编写方法
    public void work(USB usb){
        // 通过接口来调用方法
        usb.start();
        usb.stop();
    }
}
~~~

~~~java
public class Interface01 {
    public static void main(String[] args) {

        // 创建手机,相机对象
        Camera camera = new Camera();
        Phone phone = new Phone();

        // 创建计算机
        Computer computer = new Computer();
        computer.work(camera); // 把照相机接入到计算机
        System.out.println("-------------");
        computer.work(phone);// 把相机接入到计算机
    }
}

~~~

> 1.接口基本介绍:
>
> 接口就是给出一些没有实现的方法,封装到一起,到某个类使用的时候,在根据具体的情况把这些方法写出来
>
> 2.接口的语法:
>
> interface 接口名{
>
> // 属性
>
> // 方法(抽象方法/默认实现方法/静态方法)
>
> }
>
> class 类名 implements 接口名{
>
> // 自己的属性
>
> // 自己的方法
>
> // 必须实现的接口的抽象方法
>
> }
>
> 注意: jdk1.7之前接口所有的方法没有方法体,即都是抽象方法;1.8之后<font color='cyan'> 接口可以有静态方法,默认方法,也就是说接口可以有方法的默认实现</font>

~~~java
public interface InterfaceA01 {

    // 属性
    public int num = 10;
    //  方法
    // 在接口中,抽象方法可以省略abstract关键字
    public void hi();
    // 可以有默认实现方法,需要使用default关键字修饰
    default  public void ok(){
        System.out.println("ok");
    }
    // 可以有静态方法,有具体实现
    public static void cry(){
        System.out.println("cry");
    }
}

public class A01 implements InterfaceA01{
    /*
        1.如果一个类实现接口,需要将该接口所有的抽象方法都实现
     */
    @Override
    public void hi() {

    }
}
~~~

#### 7.7.2 接口细节

> 1.接口不能被实例化
>
> 2.接口中所有的方法都是public方法,接口的抽象方法,可以不用abstract修饰 void a(); -->public abstract a();
>
> 3.一个普通的类实现接口,就必须实现该接口的所有抽象方法
>
> 4.抽象类实现接口,可以不用实现接口的抽象方法

~~~java
public class InterfaceDetail01 {
    public static void main(String[] args) {
          // 1.接口不能被实例化
//        new InterfaceA03(); // 'InterfaceA03' 为 abstract；无法实例化
    }
}

interface InterfaceA03{

    void a();
    public abstract void b(); // 2.public abstract 都是冗余的
    void hi();

}

// 3.一个普通的类实现接口,就必须实现该接口的所有抽象方法
class A03 implements InterfaceA03{ // alt + enter 提示

    @Override
    public void a() {

    }

    @Override
    public void b() {

    }

    @Override
    public void hi() {

    }
}

// 4.抽象类实现接口时可以不实现接口的(抽象)方法
abstract class B03 implements InterfaceA03{

}
~~~

> 5.一个类可以同时实现多个接口
>
> 6.接口中的属性只能是final,而且是public static final 修饰符,比如 int a =1 -> public static final int a = 1; (必须初始化)
>
> 7.接口中属性的访问形式: 接口名.属性名
>
> 8.一个接口不能继承其他的类,但是可以继承多个别的接口 interface A extend B,C{}
>
> 9.<font color='cyan'>接口的修饰符只能是 public和默认,这点和类的修饰符是一样的</font>

~~~java
public class interfaceDetail02 {
    public static void main(String[] args) {
        // 1.证明接口的属性都是static
        System.out.println(InterfaceA04.n1);
        // 2.证明接口的属性都是static
//        InterfaceA04.n1 =30; // 无法将值赋给 final 变量 'n1'
        // 3.证明接口的属性都是public
    }
}

interface InterfaceA04{

//    protected int n = 2; // 此处不允许使用修饰符 'protected'
    int n1 = 1; // 2. public static final int n1 =1;如何证明?
    void hi();
}

interface InterfaceA05{
    void show();
}


// 1.一个类可以同时实现多个接口
class B04 implements InterfaceA04, InterfaceA05{

    @Override
    public void hi() {

    }

    @Override
    public void show() {

    }
}

// 3.接口与接口是继承(多继承),类与接口是实现
interface InterfaceA06 extends InterfaceA04, InterfaceA05{

}

// 4. 接口的修饰符只能是 public和默认,这点和类的修饰符是一样的
//private interface InterfaceA07{ // 此处不允许使用修饰符 'private'
//
//}
~~~

#### 7.7.3 接口练习

~~~java
interface A{
    int a = 30; // public static final
}

class B implements A { // 正确
    
}
//main中:
B b = new B();
System.out.println(b.a); // 30
System.out.println(A.a); // 30
System.out.println(B.a); // 30 可以实现接口的属性
~~~

#### 7.7.4 接口VS继承

> 当子类继承了父类,就自动拥有父类的功能
>
> 如果子类需要扩展功能,就可以通过接口来实现扩展
>
> 可以理解为: 接口实现是对单继承机制的一种补充
>
> 继承: is a   接口: like a
>
> 接口:代码解耦

~~~java
public class Monkey {
    private String name;

    public Monkey(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void climb(){
        System.out.println(getName() + "会爬树");
    }
}
~~~

~~~java
public interface Bird {
    void fly();
}

public interface Fish {

    void swimming();
}
~~~

~~~java
public class LittleMonkey extends Monkey implements Bird, Fish{

    public LittleMonkey(String name) {
        super(name);
    }


    @Override
    public void fly() {
        System.out.println(getName() + "像鸟儿一样飞翔");
    }

    @Override
    public void swimming() {
        System.out.println(getName() + "像鱼儿一样游泳" );
    }
}
~~~

~~~java
public class Interface04 {
    public static void main(String[] args) {

        LittleMonkey littleMonkey = new LittleMonkey("悟空");
        littleMonkey.climb();
        littleMonkey.fly();
        littleMonkey.swimming();
    }
}
~~~

#### 7.7.5 接口的多态特性

> 1.接口多态参数,接口入门的案例已经说明,<font color='cyan'> 接口的引用可以指向接口实现类的实例(对象)</font>

~~~java
public class InterfacePolyParameter {
 public static void main(String[] args) {
        //接口的多态体现
        //接口类型的变量 if01 可以指向 实现了 IF 接口类的对象实例
        IF if01 = new Monster();
        if01 = new Car();
        //继承体现的多态
        //父类类型的变量 a 可以指向 继承 AAA 的子类的对象实例
        AAAa = new BBB();
        a = new CCC();
    }
}

interface IF {}
class Monster implements IF{}
class Car implements IF{}
class AAA{}
class BBB extendsAAA{}
class CCC extendsAAA{}
~~~

> 2.接口多态数组

~~~java
public class Interface01 {
    public static void main(String[] args) {

        // 创建手机,相机对象
        Camera camera = new Camera();
        Phone phone = new Phone();

        // 创建计算机
        Computer computer = new Computer();
        computer.work(camera); // 把照相机接入到计算机
        System.out.println("-------------");
        computer.work(phone);// 把相机接入到计算机

        // 补充多态数组
        USB[] myUsb = new USB[2];
        myUsb[0] = new Phone();
        myUsb[1] = new Camera();

        for (int i = 0; i < myUsb.length; i++) {
            // 调用start()
            myUsb[i].start();
            // 调用phone独有的怎么办? -- 向下转型
//            myUsb[i].call
            if (myUsb[i] instanceof Phone){
                ((Phone) myUsb[i]).call();
            }
            
       }

    }
}
~~~

> 3.接口多态传递

~~~java
public class Interface05 {
    // 接口引用 指向 实现类 对象
    A05 a05 = new Teacher();
    // 多态怎么传递呢?
    A06 a06 = new Teacher(); // 无法传递,怎么实现?
}

interface A05 extends A06{

}

interface A06{

}

class Teacher implements A05{ // 也可以看出,实现也是一层一层,从最高层开始,这就是多态传递现象

}

// C(class)-implements->A(interface) -extends-> B(interface)
// 此时 B b = new C(); 就可以进行传递
~~~

#### 7.7.5 接口练习

~~~java
public class InterfaceExercise02 {
 public static void main(String[] args) {
 }
}
interface A{ // 1min 看看
 int x = 0;
} //想到 等价 public static final int x = 0;
class B {
 int x = 1;
} //普通属性
class C extends B implementsA{
 public void pX() {
        //System.out.println(x); //错误，原因不明确 x
            //可以明确的指定 x
        //访问接口的 x 就使用 A.x
        //访问父类的 x 就使用 super.x
        System.out.println(A.x + " " + super.x);
 }
 public static void main(String[] args) {
  new C().pX();
 }
}
~~~

### 7.8 四种内部类

> 如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2)  <font color='cyan'> 匿名内部类</font>
> 定义在成员位置 (1) 成员内部类 (2) 静态内部类

#### 7.8.1 内部类的基本介绍

> 一个类的内部又完整的嵌套了另外一个类结构,被嵌套的类称为内部类(inner class), 嵌套其他类的类称为外部类(outer class).内部类是我们类的第五大部分[属性,方法,构造器,代码块,内部类],内部类最大的特点就是可以直接访问私有属性,并且可以体现出类与类之间的包含关系.
>
> 1.基本语法:
>
> class Outer{ // 外部类
>
> class inner{ // 内部类
>
> }
>
> }
>
> class Other{ //  其他类
>
> }

~~~java
// 内部类简介
/*
    定义在局部位置上
        局部内部类(有类名)
        匿名内部类(没有类名)
    定义在成员位置上
        成员内部类(无static)
        静态内部类(有static)
 */
public class InnerClass01 { // 外部其他类
}

class OuterClass{

    private int n1 = 10;

    public void m1(){
        System.out.println("m1()");
    }

    public OuterClass(int n1) {
        this.n1 = n1;
    }

    {
        System.out.println("代码块");
    }
    // 内部类
    class InnerClass{

    }
}
~~~

#### 7.8.2 局部内部类

> 说明:局部内部类是定义在外部类的局部位置,比如方法中,并且有类名
>
> ①可以直接访问外部的所有成员,包括私有的
>
> ②不能添加访问修饰符,因为其地位就是一个布局变量(类),局部变量不能使用修饰符,但是可以使用final修饰符,因为局部变量也可以使用final修饰符
>
> ③作用域:仅仅在定义它的方法或者代码块中
>
> ④局部内部类--访问--->外部类成员(访问方式:直接访问)
>
> ⑤外部类--访问--->局部内部类的成员,(访问方式:创建对象再访问,注意: 必须在作用域中)
>
> 总结:
>
> 1) 局部内部类定义在方法/代码块中
>
> 2) 作用域在方法体或者代码块中
>
> 3) 本质依然是个类
>
> ⑥外部其他类 --> 不能访问局部内部类(因为局部内部类地位是个局部变量)
>
> ⑦如果外部类和局内部类的成员重名时,默认遵从就近原则,如果想访问外部类的成员,则可以使用(外部类名.this.成员)去访问

~~~java
public class InnerClass02 {
    public static void main(String[] args) {
        Outer02 outer02 = new Outer02();
        outer02.m1();
        //⑥外部其他类 --> 不能访问局部内部类(因为局部内部类地位是个局部变量)
//        InnerClass001 InnerClass001 = new InnerClass001(); //无法解析符号 'InnerClass001'
        System.out.println(outer02);
    }
}

class Outer02{
    private int n1 = 100;
    private void m2(){
        System.out.println("私有方法m2");
    }
    public void m1(){
        //局部内部类是定义在外部类的局部位置,比如方法中,并且有类名
        //②不能添加访问修饰符,因为其地位就是一个布局变量(类),局部变量不能使用修饰符,但是可以使用final修饰符,因为局部变量也可以使用final修饰符
         final class InnerClass001{ // 局部内部类本质还是一个类
             //⑦如果外部类和局内部类的成员重名时,默认遵从就近原则,如果想访问外部类的成员,则可以使用(外部类名.this.成员)去访问
             private int n1 =200;
            //①可以直接访问外部的所有成员,包括私有的
            public void f1(){
                //④局部内部类--访问--->外部类成员(访问方式:直接访问)
                System.out.println("n1 = " + n1); //200
                //Outer02.this是什么意思呢? 本质就是外部类的对象,谁调用m1(),则Outer02.this就是哪个对象 --> 验证2
                System.out.println("外部的n1 = " + Outer02.this.n1);//100
                m2(); //私有方法m2
                //验证本质就是外部类的对象,谁调用f1(),则Outer02.this就是哪个对象,打印hashCode,此时这个对象就是outer02
                System.out.println(Outer02.this); //可以看出是一致的
            }
        }
        //⑤外部类--访问--->局部内部类的成员,(访问方式:创建对象再访问,注意: 必须在作用域中)
        InnerClass001 innerClass001 = new InnerClass001();
        innerClass001.f1();
        //可以看出在局部范围内(方法),还是可以继承的,但是加上final修饰之后,就不可以
//        class InnerClass03 extends InnerClass02{
//
//        }
    }
    // ③作用域:仅仅在定义它的方法或者代码块中
    {
        class InnerClass03{

        }
    }
}
~~~

#### 7.8.3 匿名内部类(!!!!)

> <font color='cyan'> (1)本质是类(2)内部类(3)该类没有名字(4)同时本身是个对象</font>
>
> 说明:匿名内部类是定义在外部类的局部位置,比如方法中,且没有类名(表面没有,不用关注)
>
> 1.基本语法
>
> new 类或者接口(参数列表){
>
> 类体
>
> };

~~~java
public class InnerClass03 {
    public static void main(String[] args) {
        OutClass03 outClass03 = new OutClass03();
        outClass03.m1();
        outClass03.m2();
        outClass03.m3();
    }
}

class OutClass03{
    private int n = 100;

    public void m1(){
        /**
          基于接口的匿名内部类
        */
        // 1.需求: 想使用A接口,并创建对象? --> 传统方式解决: 写一个实现类,并创建对象引用
        A a = new B();
        a.cry();
        // 这样的写法的问题是什么? --> B类只是使用一次,以后再也不使用了 --> 使用匿名内部类来简化开发
        /*
           aa的编译类型 --> A
           aa的运行类型 --> 就是匿名内部类,XXX-->OutClass03$1
           class XXX implments A{
                public void cry() {
                    System.out.println("匿名叫唤");
                }
           }
           jdk底层在创建匿名内部类OutClass03$1,立即就创建了OutClass03$1实例,并将地址返回给aa
           匿名内部类使用一次就不能再使用了,注意: 类不能使用,但是实例(对象)aa可以使用
           标点符号; 要保留
         */
        A aa = new A() {
            public void cry() {
                System.out.println("匿名叫唤");
            }
        };
        aa.cry();
        System.out.println("aa的运行类型" + aa.getClass()); // aa的运行类型 OutClass03$1,可见是底层实现,getClass()获取对象的运行类型
        aa.cry();
    }

    /**
     *  基于类的匿名内部类
     */
    public void m2(){
        // 匿名内部类
        /*
            1.C的编译类型 --> C
            2.C的运行类型 --> 匿名内部类 OutClass03$2
            3.底层还是会创建类
            class OutClass03$2 extends C{

            }
            4.同时也直接返回了匿名内部类OutClass03$2的实例
            5.标点符号; 要保留
            6.注意匿名类的参数列表str 会传递给C的构造器
         */
        C c = new C("str"){
            // 匿名内部类可以重写f1()
            @Override
            public void f1() {
                System.out.println("匿名内部类可以重写f1()");
            }
        };
        System.out.println("c的运行类型" + c.getClass());
    }
~~~

> 2.匿名内部类<font color='cyan'>既是一个类的定义,同时他本身也是一个对象</font>,因此从语法上来看,它既有定义类的特征,也有创建对象的特征,因此<font color='cyan'>可以直接调用匿名内部类的方法</font>
>
> 3.可以直接访问外部类的所有成员,包括私有的
>
> 4.不能添加访问修饰符,因为他的地位就是一个全局变量
>
> 5.作用域:仅仅在定义它的方法或者代码块中
>
> 6.匿名内部类--访问--->外部类成员(访问方式:直接访问)
>
> 7.外部其他类--不能访问--->匿名内部类(地位就是一个全局变量)
>
> 8.如果外部类和匿名内部类的成员重名时,匿名内部类访问的话,默认遵循就近原则,如果想访问外部类成员,则可以使用(外部类类名 + this + 成员名)区访问

~~~java
public class InnerClass04 {
    public static void main(String[] args) {
        OutClass04 outClass04 = new OutClass04();
        outClass04.f1();
    }
}

class OutClass04{
    private int n1 = 99;
    public void f1(){
        int n1 = 100;
        // 创建一个基于类的的匿名内部类
        A04 a04 = new A04(){
            @Override
            public void hi() {
                System.out.println("匿名内部类的hi()1");
                // 访问外部的私有属性
                System.out.println("外部类的私有属性n1" + OutClass04.this.n1);
            }
        };
        a04.hi();// 动态绑定OutClass04$1

        // 也可以直接调用,匿名内部类本身也是返回了一个对象,传参都可以
        new A04(){
            @Override
            public void hi() {
                System.out.println("匿名内部类的hi()2");
            }
        }.hi();
    }

}

class A04{
    public void hi(){
        System.out.println("A01的hi()...");
    }
}
~~~

#### 7.8.4 匿名内部类的最佳实践

> 最佳实践:当做实参直接传参,简洁高效

~~~java
/**
 * 匿名内部类的最接实践:传统方法是硬编码,如果实现类修改,则所有引用此方法都修改;简洁高效
 */
public class InnerClass05 {
    public static void main(String[] args) {
        //当做实参直接传参,简洁高效
        f1(new A05() {
            @Override
            public void show() {
                System.out.println("这是一幅名画");
            }
        });
        //传统方式:先写一个实现类,实现接口方法,f1再调用实现类f1(new Example)
        f1(new Example());
    }

    // 静态方法,形参是接口类型
    public static void f1(A05 a05){
        a05.show(); //a05的编译类型是A05,但是这个方法怎么写完全可以自己去实现
    }
}
//接口
interface A05{
    void show();
}
//传统方式: 编写实现类
class Example implements A05{
    @Override
    public void show() {
        System.out.println("传统的一幅画");
    }
}
~~~

#### 7.8.5 匿名内部类练习

~~~java
/*
    1.有一个铃声接口Bell,里面有个ring方法
    2.有一个手机类Cellphone,具有闹钟功能alarmClock,参数是Bell类型
    3.测试手机类的闹钟功能,通过匿名内部类(对象)作为参数,打印"懒猪起床了"
    4.再传入另一个匿名内部类(对象), 打印"小伙伴上课了"
 */
public class InnerClassExercise01 {
    public static void main(String[] args) {
        Cellphone cellphone = new Cellphone();
        cellphone.alarmClock( // 传递的参数是实现了Bell接口的匿名内部类; 重写了ring();相当于bell = 匿名内部类
                new Bell() {
                    @Override
                    public void ring() {
                        System.out.println("懒猪起床了");
                    }
                }
        );

        cellphone.alarmClock(
                new Bell() {
                    @Override
                    public void ring() {
                        System.out.println("小伙伴上课了");
                    }
                }
        );

    }
}

interface Bell{
    void ring();
}

class Cellphone{

    public void alarmClock(Bell bell){
        System.out.println(bell.getClass()); // 打印运行类型
        bell.ring(); // 动态绑定--到指定的运行类型区执行ring()
    }
}
// 涉及 继承,多态,动态绑定,内部类综合
~~~

#### 7.8.6 成员内部类

> 说明:成员内部类是定义在外部类的成员位置,并且没有static修饰
>
> 1.可以直接访问外部类的所有成员,包含私有的
>
> 2.可以添加任意访问修饰符(public protected 默认 private),因为它的地位就是一个成员
>
> 3.作用域:和外部类的其他成员一样,为整个类体; 比如:在外部类的成员方法中创建成员内部类对象,再调用方法
>
> 4.成员内部类--访问-->外部类成员[访问方式:直接访问]
>
> 5.外部类--访问-->成员内部类[访问方式:创建对象,再访问]
>
> 6.外部其他类--访问-->成员内部类
>
> 7.如果外部类和内部类成员重名时,内部访问的话,默认遵循就近原则,如果想访问外部类的成员,则可以使用(外部类名.this.成员)去访问

~~~java
public class InnerClass06 {
    public static void main(String[] args) {
        OuterClass06 outerClass06 = new OuterClass06();
        outerClass06.test();
        //6.外部其他类--访问-->成员内部类,三种方式
        //①outerClass06.new InnerClass06();相当于把 new InnerClass06() 当做是outerClass06对象的成员;就是个语法不用特别纠结
        OuterClass06.InnerClass06 innerClass06 = outerClass06.new InnerClass06();
        innerClass06.say();

        //②在外部类中编写一个方法,返回内部类的对象实例
        OuterClass06.InnerClass06 innerClass066 = outerClass06.getInnerClassO6Instance();// 返回的是InnerClass06
        innerClass066.say();

        //③外部类的实例.内部类实例.成员 本质还是第一种
        new OuterClass06().new InnerClass06().say();
    }
}

class OuterClass06{

    private int n1 = 100;
    public String name = "张三";
    private void say(){
        System.out.println("OuterClass06.say()...");
    }
    private void say1(){
        System.out.println("OuterClass06.say1()...");
    }
    //1.成员内部类是定义在外部内的成员位置上
    class InnerClass06{
        private int n1 = 99;
        public void say(){
            //4.成员内部类--访问-->外部类成员[访问方式:直接访问]
            //7.如果外部类和内部类成员重名时,内部访问的话,默认遵循就近原则,如果想访问外部类的成员,则可以使用(外部类名.this.成员)去访问
            System.out.println("n1=" + n1 + "\tname=" + name + "\t外部n1= " + OuterClass06.this.n1);
            System.out.println("成员内部类InnerClass06的say()...");
            say1();
//            say();
            OuterClass06.this.say();
        }
    }

    // 2.可以添加任意访问修饰符(public protected 默认 private),因为它的地位就是一个成员
    protected class InnerClass061{

    }
    // 3.作用域:和外部类的其他成员一样,为整个类体

    //用方法体现内部类
    //5.外部类--访问-->成员内部类[访问方式:创建对象,再访问]
    public void test(){
        // 在这里我们使用了成员内部类
        new InnerClass06().say();
    }

    //在外部类中编写一个方法,返回内部类的对象实例
    public InnerClass06 getInnerClassO6Instance(){
        return new InnerClass06();
    }
}
~~~

#### 7.8.7 静态内部类

> 说明:静态内部类是定义在外部类的成员位置,有static修饰
>
> 1.可以直接访问外部类的所有静态成员,包含私有的,但是不能直接访问非静态的成员
>
> 2.可以添加任意访问修饰符(public protected 默认 private),因为他的地位就是个成员
>
> 3.作用域:同其他的成员,为整个类体
>
> 4.静态内部类--访问-->外部类静态成员[访问方式:直接访问所有静态成员]
>
> 5.外部类--访问-->静态内部类[访问方式:创建对象,再访问]
>
> 6.外部其他类--访问-->静态内部类
>
> 7.如果外部类和静态内部类成员重名时,静态内部类访问的话,默认遵循就近原则,如果想访问外部类的成员,则可以使用(外部类名.成员)去访问

~~~java
public class InnerClass07 {
    public static void main(String[] args) {
        OutClass07 outClass07 = new OutClass07();
        outClass07.m1();

        //6.外部其他类--访问-->静态内部类
        //①因为静态内部类,是可以通过类名直接访问(前提是满足访问权限)
        OutClass07.InnerClass07 innerClass07 = new OutClass07.InnerClass07();
        innerClass07.say();
        //②编写一个方法,可以返回静态类内部类的对象实例
        OutClass07.InnerClass07 innerClass071 = outClass07.getInnerClass07Instance();
        innerClass071.say();
        //③编写一个静态的方法,直接使用外部类名.方法
        OutClass07.getInnerClass07Instance01();
    }
}

class OutClass07{
    private int n1 =10;
    private static String  name = "张三";
    private static void cry(){
        System.out.println("静态方法cry");
    }

    //InnerClass07就是静态内部类
    //1.放在外部类的成员位置,使用static修饰
    static class InnerClass07{
        private static String name = "李四";
        public void say(){
            //2.可以直接访问外部类的所有静态成员,包含私有的,但是不能直接访问非静态的成员
//            System.out.println("n1=" + n1);// 无法从 static 上下文引用非 static 字段 'n1'
            System.out.println("就近name=" +name);
            //6.如果外部类和静态内部类成员重名时,静态内部类访问的话,默认遵循就近原则,如果想访问外部类的成员,则可以使用(外部类名.成员)去访问
            System.out.println("外部类name=" +OutClass07.name);
            cry();
        }
    }

    //3.可以添加任意访问修饰符(public protected 默认 private),因为他的地位就是个成员
    private static class InnerClass071{

    }
    //4.作用域也是整个类体
    public void m1(){
        //5.外部类--访问-->静态内部类[访问方式:创建对象,再访问]
        new InnerClass07().say();
    }

    public InnerClass07 getInnerClass07Instance(){
        return new InnerClass07();
    }
    public static InnerClass07 getInnerClass07Instance01(){
        return new InnerClass07();
    }
}
~~~

#### 7.8.8 练习题

~~~java
public class InnerClassExercise02 {//外部类
    public InnerClassExercise02() {//构造器
        Inner s1 = new Inner();
        s1.a = 10;
        Inner s2 = new Inner();
        System.out.println(s2.a);
    }
    class Inner { //内部类，成员内部类
        public int a = 5;
    }
    public static void main(String[] args) {
        InnerClassExercise02 t = new InnerClassExercise02();
        Inner r = t.new Inner();//5
        System.out.println(r.a);//5
    }
}
~~~
