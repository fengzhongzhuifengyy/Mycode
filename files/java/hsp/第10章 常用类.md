## 10 常用类

### 10.1 包装类

> 说明:
>
> 包装类分类
>
> 1.针对八种基本数据类型相应的引用类型—包装类
>
> 2.有了类的特点，就可以调用类中的方法。
>
> 3.Byte,Short,Integer,Long,Float,Double的父类是 Number

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| boolean      | Boolean   |
| char         | Character |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220418232252461.png" alt="image-20220418232252461" style="zoom: 50%;" />

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220418232328407.png" alt="image-20220418232328407" style="zoom:50%;" />

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220418232357827.png" alt="image-20220418232357827" style="zoom:50%;" />

#### 10.1.1 包装类与基本数据类型的转换

> 演示: int 与 Integer,包装类和基本数据类型的转换
>
> 说明
>
> 1.jdk5前的手动装箱,拆箱方式,<font color='cyan'>装箱: 基本类型 -> 包装类型,反之,拆箱</font>
>
> 2.jdk5之后有自动装箱和拆箱方式
>
> 3.自动装箱的底层调用的是valueOf方法,比如:Integer.valueOf()

~~~java
/**
 *  演示 int 和 Integer的装箱和拆箱
 */
public class Wrapper02 {
    public static void main(String[] args) {
        //jdk5之前是手动装箱和拆箱
        int n1 = 100;
        //手动装箱(int -> Integer)
        Integer n2 = new Integer(n1);
        System.out.println(n2);
        Integer n3 = Integer.valueOf(n1);
        System.out.println(n3);
        //手动拆箱(Integer -> int)
        int n4 = n2.intValue();
        System.out.println(n4);

        //jdk5之后已自动实现自动装箱和拆箱
        //自动装箱
        int num1 = 200;
        Integer num2 = num1; // 底层使用的是 Integer.valueOf(num1);
        //自动拆箱
        int num3 = num2; // 底层使用的是num2.intValue();

    }
}
~~~

#### 10.1.2 测试题

```java
public class Wrapper03 {
    public static void main(String[] args) {
        // 下面的代码是否正确
        Double d = 100d; //ok
        Float f = 1.5f; //ok
        //下面的输出结果是否一致
        Object object = true ? new Integer(1) : Double.valueOf(2.0); //1.0
        System.out.println(object);

        Object Object1;
        if (true){
            Object1 = new Integer(1);
        }else {
            Object1 = Double.valueOf(2.0);
        }
        System.out.println(Object1); //1

        /*
            为什么会出现一个1.0,一个1呢?
            三元运算符输出是1.0不是1,因为三元运算符是一个整体,以最高精度来提升优先级
            if-else就不是按照整体来,按照分支来实现,所以是1
         */
    }
}
```

#### 10.1.3 包装类型和String类型的相互转换

> 案例演示:以Integer -> String来演示

~~~java
public class Wrapper04 {
    public static void main(String[] args) {
        //包装类(Integer) -> String
        Integer n1 = 10; //自动装箱
        //方式1
        String str1 = n1 + ""; //str1是独立出来的
        //方式2:toString()
        String str2 = n1.toString();
        //方式3:String.valueOf()
        String str3 = String.valueOf(n1);

        //String --> Integer
        String s = "12345";
        Integer num1 = Integer.parseInt(s);//这边也使用到了自动装箱
        Integer num2 = new Integer(s);
    }
}
~~~

#### 10.1.4 包装类的常用方法

> 案例演示: Integer/Character类进行说明

~~~java
public class Wrapper05 {
    public static void main(String[] args) {
        Integer n1 = 100;
        Integer n2 = 200;
        System.out.println(Integer.MAX_VALUE); //返回最小值
        System.out.println(Integer.MIN_VALUE); //返回最大值

        System.out.println(Character.isDigit('1'));//判断是不是数字
        System.out.println(Character.isLetter('a'));//判断是不是字母
        System.out.println(Character.isUpperCase('C'));//判断是不是大写
        System.out.println(Character.isLowerCase('c'));//判断是不是小写
        System.out.println(Character.isWhitespace(' '));//判断是不是空格

        System.out.println(Character.toUpperCase('b'));//转换成大写
        System.out.println(Character.toLowerCase('B'));//转换成小写

        /*
            2147483647
            -2147483648
            true
            true
            true
            true
            true
            B
            b
         */
    }
}

~~~

#### 10.1.5 包装类经典面试题

~~~java
public class Wrapper06 {
    public static void main(String[] args) {
        //看看下面代码输出什么?
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);//false

        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);//true

        Integer x = 128;
        Integer y = 128;
        System.out.println(x == y);//false
    }
}
/*
    分析:
    1.两个不同的对象,必然不同
    2.默认: Integer m = Integer.valueOf(1);
        分析源码:
        public static Integer valueOf(int i) {
            //-128 ~ 127就直接返回;return IntegerCache.cache[i + (-IntegerCache.low)]; 看下图
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
            //否则重新new
        return new Integer(i);
    }
*/
~~~

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220420213813996.png" alt="image-20220420213813996" style="zoom:50%;" />

~~~java
public class Wrapper07 {
    public static void main(String[] args) {
        //实例1
        Integer i1 = new Integer(127);
        Integer i2 = new Integer(127);
        System.out.println(i1 == i2);//false

        //实例2:
        Integer i3 = new Integer(128);
        Integer i4 = new Integer(128);
        System.out.println(i3 == i4);//false

        //实例3:
        Integer i5 = 127;//底层Integer.valueOf(127)
        Integer i6 = 127;
        System.out.println(i5 == i6); //true

        //实例4:
        Integer i7 = 128;
        Integer i8 = 128;
        System.out.println(i7 == i8); //false

        //实例5:
        Integer i9 = 127;
        Integer i10 = new Integer(127);
        System.out.println(i9 == i10);//false

        /**
         *  只要有基本数据类型进行判断的就是  值是否相等
         */
        //实例6:
        Integer i11 = 127;//底层Integer.valueOf(127),从数组取值127
        int i12 = 127;
        System.out.println(i11 == i12); //true

        //实例7:
        Integer i13 = 128;
        int i14 = 128;
        System.out.println(i13 == i14); //true
    }
}
~~~

### 10.2 String类

#### 10.2.1 String类的基本介绍

> 说明:
>
> 1) String对象用于保存字符串,也就是一组字符序列;
>
> 2) 字符串常量对象是用双引号扩起的字符序列;例如:"你好"
>
> 3) 字符串的字符使用Unicode字符编码,一个字符(不区分字母还是汉字)占两个字节
>
> 4) String类较常用的构造器:
>
> String s1 = new String();
>
> String s2 = new String(String original);
>
> String s3 = new String(char[] a);
>
> String s4 = new String(char[] a, int startIndex, int count);
>
> String s5 = new String(byte[] b);
>
> 5) String 类实现了接口 Serializable [String可以串行化即可以在网络传输]
>                 接口 Comparable [String对象可以比较大小]
>
> 6) String是final修饰,不能被其他的类继承
>
> 7) String 有属性 private final char value[]; 用于存放字符串内容(The value is used for character storage)
> 8) 一定要注意：value 是一个 final 类型， <font color='cyan'>不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变化</font>即空间开辟的地址不能修改,不是内容不能修改

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220420233021073.png" alt="image-20220420233021073" style="zoom:50%;" />

~~~java
public class String01 {
    public static void main(String[] args) {

        /*
            查看源码:
            public final class String
                implements java.io.Serializable, Comparable<String>, CharSequence {...}
            1.String implements Serializable,说明:String可以串行化,实现网络传输
            2.String implements Comparable,说明:String对象可以相互比较
            3.String implements CharSequence,说明:实现了字符序列
         */

        //1.String对象用于保存字符串,也就是一组字符序列;
        //2."123"就是字符串常量,双引号括起来的字符序列
        //3.字符串的字符使用unicode字符编码,一个字符(不区分字母还是汉字)占两个字节
        //4.String类较常用的构造方法很多,重载
        //5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】
        //                 接口 Comparable [String 对象可以比较大小]
        //6.String是final修饰,不能被其他的类继承
        //7. String 有属性 private final char value[]; 用于存放字符串内容(The value is used for character storage)
        //8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向
        // 新的地址，但是单个字符内容是可以变化
        String s1 = "123";
        final char[] values = {'a', 'b', 'c'};
        values[0] = 'd';
        char[] v2 = {'e', 'f'};
        //8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向
        // 新的地址，但是单个字符内容是可以变化
//        values = v2; // 不可以修改value的地址
    }
}
~~~

#### 10.2.2 创建String对象的两种方式

> 说明:
>
> 方式1: 直接赋值, String s1 = "study"
>
> 方式2: 调用构造器 String s2 = new String("study")

#### 10.2.3 两种创建 String 对象的区别

> 1.方式1:先从常量池查看是否有"study"数据空间,如果有,直接指向;如果没有则重新创建,然后指向,s1最终指向的是常量池的空间地址
>
> 2.方式2:先在堆中创建空间,里面维护了value属性,指向常量池的study空间,如果常量池没有"study",重新创建,如果有,直接通过value指向,最终指向的是堆中的空间地址

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220423104924589.png" alt="image-20220423104924589" style="zoom: 67%;" />

#### 10.2.4 练习题

> 1.测试题:
>
> String a = "abc";
>
> String b = "abc";
>
> System.out.println(a.equals(b)); //t
>
> System.out.println(a==b); //t

> 2.测试题:
>
> String a = new String("abc");
>
> String b = new String("abc");
>
> System.out.println(a.equals(b)); //t
>
> System.out.println(a==b); //f

> 3.测试题
>
> String a = "ssh";
>
> String b = new String("ssh");
>
> System.out.println(a.equals(b)); //t
>
> System.out.println(a==b); //f
>
> System.out.println(a==b.intern()); //t
>
> System.out.println(b==b.intern()); //f
>
> // <font color='cyan'>a.intern()方法最终返回的是常量池的地址(对象/引用)</font>

> 4.测试题
>
> String s1 = "ssh";
>
> String s2 = "java";
>
> String s4 = "java";
>
> String s3 = new String("java");
>
> System.out.println(s2 == s3);//f
>
> System.out.println(s2 == s4);//t
>
> System.out.println(s2.equals(s3));//t
>
> System.out.println(s1 == s2);//f

> 5.测试题
>
> Person p1 = new Person();
>
> p1.name = "edu";
>
> Person p2 = new Person();
>
> p2.name = "edu";
>
> System.out.println(p1.name.equals(p2.name));//t
>
> System.out.println(p1.name == p2.name)//t
>
> System.out.println(p1.name == "edu")//t
>
> 
>
>
> String s1 = new String("bcd");
>
> String s2 = new String("bcd");
>
> System.out.println(s1 == s2)//f

#### 10.2.5 字符串的特性

> 1) String 是一个final类,代表不可变的字符序列
>
> 2) 字符串是不可变的,一个字符串对象一旦被分配,其内容是不可变的

> 1.以下语句创建了几个对象?
>
> String s1 = "hello";
>
> s1 = "haha"
>
> // 创建了两个对象,都是字符串常量对象

> 2.String a = "hello" + "abc",创建了几个对象?3个 错
>
> 分析: -->等价于: String a = "helloabc"; 因此只有一个对象

> String a = "hello";
>
> String b = "abc";
>
> String c = a + b;
>
> 3.请问创建了几个对象? 3个
>
> 分析:String c = a + b到底是如何执行的?

~~~java
public class String02 {
    public static void main(String[] args) {
        String a = "hello";

        String b = "abc";

        String c = a + b;
        /*
            分析源码:
            1.先创建一个StringBuilder sb = new StringBuilder();
            2.执行sb.append("hello");
            3.再次执行sb.append("abc")
            4.再次调用sb.toString()会返回String str = "helloabc"
            5.最终其实是让 str 指向堆中的对象(String)value[]的指向池中的"helloabc"
            //最终结果是常量池3个堆中2个
            小结:
            底层StringBuilder sb = new StringBuilder();sb.append(a);sb.append(b);sb是在堆中,并且append是在原来的字符串的基础上追加的
            规则:
            String c1 = "ab" + "cd";常量相加,看的是池
            String c1 = ab + cd;变量相加,是在堆中
         */
        String d = "helloabc";
        System.out.println(c == d);//真还是假? false 因为c的底层是在堆中创建的对象
        String e  = "hello" + "abc";//直接看池
        System.out.println(d == e);//真还是假? true
    }
}
~~~

> 测试题4:
>
> String s1 = "hspedu"; //s1指向池hspedu
>
> String s2 = "java"; //s2指向池java
>
> String s5 = "hspedujava";//s5指向池hspedujava
>
> String s6 = (s1 + s2).intern();//s6指向池中hspedujava
>
> Sysyem.out.println(s5 == s6); //t
>
> Sysyem.out.println(s5.equals(s6)); //t

> 5下面程序运行结果?
>
> public class Test1{
>
> String str = new String("hsp");
>
> final char[] ch = {'j', 'a', 'v', 'a'};
>
> public void change(String str, char ch[]){
>
> str = "java";
>
> ch[0] = 'h';
>
> }
>
> public static void main(){
>
> Test1 ex = new Test1();
>
> ex.change(ex.str, ex.ch);
>
> Sysyem.out.println(ex.str + " and ");
>
> Sysyem.out.println(ex.ch);
>
> }
>
> } //hsp and hava

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220423225351501.png" alt="image-20220423225351501" style="zoom:50%;" />

#### 10.2.6 String类的常见方法

> 说明:
>
> String类是保存字符常量的,每次更新都需要重新开辟空间,效率低,因此java设计者提供了StringBuilder 和 StringBuffer 来增强String的功能提高效率;
>
> String s = new String("");
>
> for(int i = 0; i < 80000; i++){
>
> s += "hello";
>
> }
>
> 1.常用的方法:
>
> equals(): 区分大小写,判断内容是否相等
>
> equalsIgnoreCase: 忽略大小写判断内容是否相等
>
> length(): 获取字符的个数,字符串的长度
>
> indexOf(): 获取字符在字符字符串中第一次出现的索引,索引从0开始,如果找不到,返回-1
>
> lastIndexOf(): 获取字符在字符串中最后一次出现的索引,索引从0开始,如果找不到,返回-1
>
> subString(): 截取指定范围的子串
>
> trim():去除前后空格
>
> charAt():获取某个索引处的字符,注意不能使用Str[index]这种方式
>
> ----------------------------------------------------------
>
> toUperCase(): 将字符串转换成大写
>
> toLowerCase(): 将字符串转换成小写
>
> concat(): 进行字符串拼接
>
> replace(): 替换字符串中的字符
>
> split(): 分隔字符串,对于某些字符串我们需要转义| \\\等
>
> compareTo(): 比较两个字符串的大小,如果前者大,则返回正数,后者大,则返回负数,如果相等,返回0
>
> toCharArray(): 转换成字符数组
>
> format(): 格式化字符串,%s字符串, %c字符, %d整型, %.2f浮点型

~~~java
public class String03 {
    public static void main(String[] args) {
        //equals(): 区分大小写,判断内容是否相等
        String str1 = "hello";
        String str2 = "Hello";
        System.out.println(str1.equals(str2));//false

        //equalsIgnoreCase: 忽略大小写判断内容是否相等
        String str3 = "jhoN";
        if ("jhon".equalsIgnoreCase(str3)) {
            System.out.println("success");//success
        } else {
            System.out.println("fail");
        }

        //length(): 获取字符的个数,字符串的长度
        System.out.println("123".length());//3

        //indexOf(): 获取字符在字符在字符串中第一次出现的索引,索引从0开始,如果找不到,返回-1
        String str4 = "123@321";
        int index1 = str4.indexOf('@');
        System.out.println(index1);//3
        System.out.println("45".indexOf("5"));//1
        System.out.println(str4.indexOf("123"));//0

        //lastIndexOf(): 获取字符在字符串中最后一次出现的索引,索引从0开始,如果找不到,返回-1
        String str5 = "123@321";
        int index2 = str5.lastIndexOf("1");
        System.out.println(index2);//6

        //subString(): 截取指定范围的子串
        String str6 = "hello,456";
        System.out.println(str6.substring(6));//截取后面的字符从索引6开始截取至后面所有的内容 456
        System.out.println(str6.substring(0, 5));///截取后面的字符从索引0取到索引5-1即{[0,5)} hello

        //trim():去除前后空格
        String str7 = " 4 56 ";
        System.out.println(str7.trim());//4 56

        //charAt():获取某个索引处的字符,注意不能使用Str[index]这种方式
        String str8 = "slb";
        System.out.println(str8.charAt(0));//s

        //toUperCase():将字符串转换成大写
        String str9 = "txl";
        System.out.println(str9.toUpperCase());//TXL

        //toLowerCase():将字符串转换成小写
        String str10 = "TJJ";
        System.out.println(str10.toLowerCase());//tjj

        //concat():进行字符串拼接
        String str11 = "孙悟空";
        str11 = str11.concat("猪八戒").concat("沙和尚").concat("白龙马");
        System.out.println(str11);//孙悟空猪八戒沙和尚白龙马

        //replace(): 替换字符串中的字符(old, new)
        //注意:str12.replace()执行后返回的结果是新的替换过的内容(str),对Str12没有任何影响
        String str12 = "孙2悟2空2";
        System.out.println(str12.replace('2', 's'));//孙s悟s空s
        System.out.println(str12.replace("2", "3"));//孙3悟3空3
        System.out.println(str12);//孙2悟2空2

        //split(): 分隔字符串,对于某些字符串我们需要转义| \\\等
        //分析split():
        //以","为标准,对str13进行分割,返回的是String[]
        String str13 = "123,456,789";
        String[] split1 = str13.split(",");
        for (String values:split1){
            System.out.print(values + " ");//123 456 789
        }
        System.out.println("某些符号需要进行转义,转义符'\'");
        String str14 = "E:\\aaa\\bbb";
        String[] split2 = str14.split("\\\\");
        for (String values:split2){
            System.out.print(values + " ");//E: aaa bbb
        }
        System.out.println();

        //compareTo(): 比较两个字符串的大小,如果前者大,则返回正数,后者大,则返回负数,如果相等,返回0
        //根据源码解读: 1.如果长度相同并且每个字符相同就返回0( return len1 - len2;); 2.如果长度相同或者不相同,但是在进行比较时可以区分大小,返回:(if (c1 != c2) {
        //                        return c1 - c2;
        //                    }); 3.如果前面部分都相同长度不同,就返回str15.length() - str16.length() 本质:(return len1 - len2;)
        String str15 = "hap";
        String str16 = "hap1";
        System.out.println(str15.compareTo(str16));// -1
        /*
            compareTo()源码:
            public int compareTo(String anotherString) {
                int len1 = value.length;
                int len2 = anotherString.value.length;
                int lim = Math.min(len1, len2);
                char v1[] = value;
                char v2[] = anotherString.value;

                int k = 0;
                while (k < lim) {
                    char c1 = v1[k];
                    char c2 = v2[k];
                    if (c1 != c2) {
                        return c1 - c2;
                    }
                k++;
        }
        return len1 - len2;
    }
         */

        //toCharArray(): 转换成字符数组
        String str17 = "happy";
        char[] ch = str17.toCharArray();
        for (char values:ch){
            System.out.print(values + " ");//h a p p y
        }
        //format(): 格式化字符串,%s字符串, %c字符, %d整型, %.2f浮点型
        String name = "jack";
        int age = 15;
        double score = 98.336;
        char gender = '男';
        String info = "我的姓名是" + name + "我的年龄" + age + "我的成绩" + score + "我的性别" + gender;
        String info2 = String.format("我的姓名是%s我的年龄%d我的成绩%.2f我的性别%c", name, age, score, gender);
        System.out.println(info);
        System.out.println(info2);
        //1. %s , %d , %.2f %c 称为占位符
        //2. 这些占位符由后面变量来替换
        //3. %s 表示后面由 字符串来替换
        //4. %d 是整数来替换
        //5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理
        //6. %c 使用 char 类型来替换
    }
}
~~~

### 10.3 StringBuffer

#### 10.3.1 StringBuffer类的基本介绍

> 说明:
>
> java.lang.StringBuffer 代表可变的字符序列,可以对字符串的内容进行增删;
>
> 很多方法都和String相同,但是StringBuffer是可变长度;
>
> StringBuffer是一个容器

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220425232213534.png" alt="image-20220425232213534" style="zoom:50%;" />

#### 10.3.2 String VS StringBuffer

> 1.String保存的是<font color='cyan'>字符串常量</font>,里面的值不能更改,每次String类的更新实际上就是更新地址,效率低// <font color='cornflowerblue'>private final char[] value</font>
>
> 2.StringBuffer保存的是<font color='cyan'>字符串变量</font>,里面的值可以更改,每次StringBuffer的更新实际上可以更新内容,不用每次更新地址,效率较高 //<font color='cornflowerblue'>char[] value(放在堆中)</font>

```java
public class StringBuffer01 {
    public static void main(String[] args) {
        /*
            分析:
            1.StringBuffer的直接父类是AbstractStringBuilder
            2.StringBuffer实现了Serializable, 即StringBuffer的对象也是可以串行化的
            3.针对下面的"hello",它的位置到底在哪里???? ---查看源码: 有属性char[] value,不是final修饰,该value数组存放 字符串内容,引出存放在堆中,而不是常量池
                abstract class AbstractStringBuilder implements Appendable, CharSequence {
                    char[] value;
            4.StringBuffer 是一个final类,不能被继承
            5,因为StringBuffer字符内容是存储在char[] values,所以在变化(增加/删除)不用每次都更换地址,即创建新的对象
     */

        StringBuffer stringBuffer = new StringBuffer("hello");
    }
}
```

#### 10.3.3 StringBuffer的构造器

> StringBuffer(): 构造一个没有字符的字符串缓冲区，初始容量为16个字符。
>
> StringBuffer(CharSequence seq): 构造一个包含与指定的相同字符的字符串缓冲区 CharSequence 。---不常用
>
> StringBuffer(int capacity): 构造一个没有字符的字符串缓冲区和指定的初始容量。
>
> StringBuffer(String str):构造一个初始化为指定字符串内容的字符串缓冲区。

```java
public class StringBuffer02 {
    public static void main(String[] args) {

        //构造器使用
        //创建一个大小为16的char[],用于存放字符内容
        StringBuffer stringBuffer = new StringBuffer();
        
        //通过构造器可以指定char[]的大小
        StringBuffer stringBuffer1 = new StringBuffer(100);
        
        //通过给一个String创建StringBuffer,char[]大小就是str.length+16
        StringBuffer hello = new StringBuffer("hello");
        
    }
}
```

#### 10.3.4 StringBuffer的转换

```java
public class StringBuffer03 {
    public static void main(String[] args) {

        //String --> StringBuffer
        String str = "hello";
        //方式1 使用构造器
        //注意:返回的才是StringBuffer对象,对str本身没有影响
        StringBuffer stringBuffer = new StringBuffer(str);
        //方式2 通过append()
        StringBuffer stringBuffer1 = new StringBuffer();
        StringBuffer stringBuffer2 =  stringBuffer1.append(str);


        //StringBuffer --> String
        StringBuffer stringBuffer3 = new StringBuffer(100);
        //方式1 通过toString()
        stringBuffer3.toString();

        //方式2 通过构造器
        String string = new String(stringBuffer1);

    }
}
```

#### 10.3.5 StringBuffer的常用方法

> 1)增 append()
>
> 2)删 delete(start, end) 
>
> 3)改 replace(start, end, string):将start --- end之间的内容替换掉,不包含end
>
> 4)查 indexOf(): 查找子串在字符串第一次出现的索引,如果没有返回-1
>
> 5)插 insert() 
>
> 6)获取长度 length()

~~~java
public class StringBuffer04 {
    public static void main(String[] args) {

        StringBuffer s = new StringBuffer("hello");
        //增
        s.append(',');//hello,
        s.append("张三丰");//hello,张三丰
        s.append("赵敏").append(100).append(true).append(10.5);//hello,张三丰赵敏100true10.5
        System.out.println(s.toString());//s.toString(),可以追源码查看

        //删除
        //要求删除索引为>=start && <end的字符; 删除[11,14)
        s.delete(11,14);
        System.out.println(s);//hello,张三丰赵敏true10.5

        //修改
        //将[9,11)替换为"周芷若"
        s.replace(9, 11, "周芷若");
        System.out.println(s);//hello,张三丰周芷若true10.5

        //插入
        //在索引为9的位置插入"赵敏",原来索引为9的内容自动后移
        s.insert(9, "赵敏");
        System.out.println(s);//hello,张三丰赵敏周芷若true10.5

        //长度
        System.out.println(s.length());//22

    }
}
~~~

#### 10.3.6 StringBuffer类练习题

~~~java
//看下面的代码输出是什么?为什么
public class StringBufferExercise01 {
    public static void main(String[] args) {
        String str = null;
        StringBuffer sb = new StringBuffer();
        sb.append(str);
        /*
            此时查看底层源码:知道调用的是abstractStringBuilder 的 appendNull(),返回的值存有"null"
         */
        System.out.println(sb.length());//4
        System.out.println(sb);//null
        StringBuffer sb1 = new StringBuffer(str);
        /*
            查看源码:
            public StringBuffer(String str) {
                super(str.length() + 16);
                append(str);
            }
            str.length()报错空指针异常
         */
        System.out.println(sb1);
    }
}
~~~

~~~java
//输入商品名称和商品价格,要求打印效果实例
//商品名 商品价格
// 手机   123,456,789
 //要求:价格的小数点前面每三位用逗号隔开
public class StringBufferExercise02 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入你的商品: ");
        String str1 = sc.next();
        System.out.println("请输入你的价格: ");
        Double price = sc.nextDouble();
        String str2 = price.toString();
//        System.out.println(str2);
        String s1 = "商品名\t商品价格\n";
        StringBuffer sb1 = new StringBuffer(s1);
        sb1.append(str1);
//        System.out.println(sb1);
        //重点处理价格,思路:1.转换成StringBuffer进行操作insert ","操作 ;2.插入的思路就是找到数字的.进行向前3位插入
        StringBuffer sb2 = new StringBuffer(str2);
//        int i = stringBuffer1.lastIndexOf(".");
//        stringBuffer1.insert(i - 3, ',');

        //当价格数字过长就需要进行循环处理
        for (int x = sb2.indexOf(".") - 3 ; x > 0; x -= 3){
            sb2.insert( x,',');
        }
        System.out.println(sb2);
        //进行字符串的拼接
        sb1.append("\t\t").append(sb2);
        System.out.println(sb1);
    }
}
~~~

### 10.4 StringBuilder

#### 10.4.1 基本介绍

> 1.一个可变的字符序列,此类提供一个与StringBuffer兼容的api,但是不保证同步(StringBuilder不是线程安全的);该类被设计用作StringBuffer的一个简易替换,<font color='cyan'>用在字符缓冲区被单个线程使用的时候</font>,如果可能,建议优先采用该类,因为在大多数实现中,它比StringBuffer要快
>
> 2.在StringBuilder上的主要操作是append 和 insert方法,可以重载这些方法,以接收任意类型的数据

<img src="F:\Typora_note\java\04 韩顺平\hsp.assets\image-20220501231007426.png" alt="image-20220501231007426" style="zoom:50%;" />

~~~java
public class StringBuilder01 {
    public static void main(String[] args) {
        /*
            1.StringBuilder也继承了abstractStringBuilder
            2.实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件)
            3.StringBuilder是final类,不能被继承
            4.StringBuilder对象的字符序列仍然是存放在其父类abstractStringBuilder的 char[] value,因此字符序列是在堆中
            5.StringBuilder的方法没有做互斥的处理,即没有synchronized关键字因此在单线程的情况下使用StringBuilder
         */
        StringBuilder stringBuilder = new StringBuilder();
    }
}
~~~



#### 10.4.2 StringBuilder的常用方法

> StringBuilder和StringBuffer均代表可变的字符序列,方法是一样的,所以使用和StringBuilder一样

#### 10.4.3 StringBuilder类

> * String StringBuffer 和 StringBuilder的比较
>
> 1)StringBuilder和StringBuffer非常类似,均代表可变的字符序列,而且方法也一样
>
> 2)String: 不可变字符序列,效率低但是复用性高
>
> 3)StringBuffer: 可变字符序列,效率较高(增/删),线程安全
>
> 4)StringBuilder: 可变字符序列,效率最高,线程不安全
>
> 5) String使用注意事项:
>
> ​	String s = "a"; //创建一个字符串
>
> ​	s += "b"; //实际上原来的字符串"a"对象已经丢弃,现在又产生一个字符串s+"b"(ab),如果多次执行这些改变字符串的内容操作,会导致大量副本字符串对象存留在内存中,降低效率,如果这样的操作放到循环中,会极大影响程序的性能==> 结论:如果我们对String做大量修改,不要使用String

> * 效率测试
>
>   StringBuilder > StringBuffer > String

~~~java
public class StringVsStringBufferVsStringBuilder {
    public static void main(String[] args) {
        long startTime = 0L;
        long endTime = 0L;
        StringBuffer buffer = new StringBuffer("");
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 80000; i++) {//StringBuffer 拼接 20000 次
        buffer.append(String.valueOf(i));
    }
    endTime = System.currentTimeMillis();
    System.out.println("StringBuffer 的执行时间：" + (endTime - startTime));

    StringBuilder builder = new StringBuilder("");
    startTime = System.currentTimeMillis();
    for (int i = 0; i < 80000; i++) {//StringBuilder 拼接 20000 次
        builder.append(String.valueOf(i));
    }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuilder 的执行时间：" + (endTime - startTime));

    String text = "";
    startTime = System.currentTimeMillis();
    for (int i = 0; i < 80000; i++) {//String 拼接 20000
        text = text + i;
    }
        endTime = System.currentTimeMillis();
        System.out.println("String 的执行时间：" + (endTime - startTime));
    }
}
~~~

> 总结:
>
> 1.如果字符串存在大量的修改操作,一般使用StringBuilder和StringBuffer
>
> 2.如果字符串存在大量的修改操作,并且在单线程情况下使用StringBuilder
>
> 3.如果字符串存在大量的修改操作,并且在多线程情况下使用StringBuffer
>
> 4.如果我们字符串很少修改,被多个对象引用,使用String,比如配置信息等

### 10.5 Math类

~~~java
public class Math01 {
    public static void main(String[] args) {
        //Math的常用方法都是静态方法
        //1.abs 绝对值
        int num1 = Math.abs(-1);
        System.out.println(num1);//1

        //2.pow 求幂
        double num2 = Math.pow(2, 4);
        System.out.println(num2);//16.0

        //3.ceil 向上取整,返回>=该参数的最小整数(转成double)
        double num3 = Math.ceil(10.5);
        System.out.println(num3);//11

        //4.floor 向下取整,返回<=该参数的最大整数(转成double)
        double num4 = Math.floor(-4.9999);
        System.out.println(num4);//-5.0

        //5.round 四舍五入,返回类型为long
        long num5 = Math.round(789.23);
        System.out.println(num5);//789

        //6.sqrt 开方
        double num6 = Math.sqrt(9.0);
        System.out.println(num6);//3.0

        //7.random 随机数[0.0 - 1.0)
        //思考: 请写出获取a-b之间的一个随机整数,a b均为整数? 2 -7
        /*
            分析:
             Math.random() * (b-a) 返回的就是 0 <= 数 <= b-a
            (1) (int)(a) <= x <= (int)(a + Math.random() * (b-a +1) )
            (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
            (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
            Math.random()*6 返回的是 0 <= x < 6 小数
            2 + Math.random()*6 返回的就是 2<= x < 8 小数
            (int)(2 + Math.random()*6) = 2 <= x <= 7
            (3) 公式就是 (int)(a + Math.random() * (b-a +1) )
         */
        for (int i=0; i<10; i++ ) {
            int num7 = (int)(2 + Math.random()*(7-2+1));
            System.out.println(num7);
        }

        //8.max 求两个数的最大值
        double num8 = Math.max(10.2, 5.3);
        System.out.println(num8);//10.2

        //9.min 求两个数的最小值
        double num9 = Math.min(10.2, 5.3);
        System.out.println(num9);//5.3
    }
}
~~~

### 10.6 Arrays类

#### 10.6.1 Arrays类的常见方法应用案例

> 说明:
>
> Arrays里面包含了一系列静态方法,用于管理或操作数组(比如排序和搜索)
>
> 1)toString():返回数组的字符串形式: Arrays.toString(arr)
>
> 2)sort():排序(自然排序和定制排序): Integer arr[] = {-1, 1,7, 0, 89};
>
> 3)binarySearch:通过二分法搜索进行查找,要求必须先排好序: int index = Arrays.binarySearch(arr, 3)

~~~java
public class Arrays01 {
    public static void main(String[] args) {
        Integer[] integers = {1, 30, 90};
        //遍历数组老方法
        for (Integer values:integers){
            System.out.print(values + " ");
        }
        //新方法 Arrays.toString() 显示数组信息
        System.out.println(Arrays.toString(integers));

        //sort() 的使用
        Integer[] arr = {1, -1, 50, 30, 90};
        //之前我们使用冒泡排序,现在我们直接使用sort()
        //因为数组是引用类型,所以通过sort()排序后,会直接影响到实参arr的原本顺序
        //通过最后的排序结果可以看出,该方法是重载的,是默认排序(从小到大)
        Arrays.sort(arr);
        System.out.println("默认排序后");
        System.out.println(Arrays.toString(arr)); //[-1, 1, 30, 50, 90]

        //也可以通过传入一个接口Comparator实现定制排序
        //调用定制排序时传入两个参数(1)排序的数组 (2)实现Comparator接口的内部类,需要实现一个compare()
        //这里体现接口编程的方式,查看源码: -->
        /*
        1.Arrays.sort(arr, new Comparator() -->
        2.(最终到)TimSort 类的 private static <T> void binarySort(T[] a, int lo, int hi, int start,Comparator<? super T> c)()
        3.执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的匿名内部类的 compare ()
            while (left < right) {
                int mid = (left + right) >>> 1;
                if (c.compare(pivot, a[mid]) < 0)
                    right = mid;
                else
                    left = mid + 1;
            }
        4.new Comparator() {
         @Override
         public int compare(Object o1, Object o2) {
             Integer i1 = (Integer) o1;
             Integer i2 = (Integer) o2;
             return i2 - i1;
            }
         }
       5.public int compare(Object o1, Object o2) 返回的值>0 还是 <0 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用;
       将来的底层框架和源码的使用方式，会非常常见
         */
        Arrays.sort(arr, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                Integer i1 = (Integer)o1;
                Integer i2 = (Integer)o2;
                return i2 - i1;
            }
        });
        System.out.println("定制排序后");
        System.out.println(Arrays.toString(arr)); //[90, 50, 30, 1, -1]
    }
}
~~~

~~~java
/**
 *  自定义Arrays模拟排序
 */
public class Arrays02 {
    public static void main(String[] args) {
        int[] arrs = {1, -1, 8, 0, 20};
        burbleSort(arrs);

        burbleSortCustomized(arrs, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                int i1 = (Integer)o1;
                int i2 = (Integer)o2;
                return i2 - i1; // 此处就控制是顺序还是逆序进行排序
            }
        });

    }

    //使用冒泡排序实现
    public static void burbleSort(int[] arrs){
        for (int i = 0; i < arrs.length -1; i++){
            for (int j = 0; j < arrs.length -1 - i; j++) {
                if (arrs[j] > arrs[j+1]){
                    int temp = arrs[j];
                    arrs[j] = arrs[j+1];
                    arrs[j+1] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(arrs));
    }

    // 需求:结合冒泡+定制
    public static void burbleSortCustomized(int[] arrs, Comparator c){
        for (int i = 0; i < arrs.length -1; i++){
            for (int j = 0; j < arrs.length -1 - i; j++) {
                //此处发生了比较,可以判断进行是按照从大到小还是从小到大进行排序
                //数组的排序由c.compare(arrs[j], arrs[j+1]) 来决定
                if (c.compare(arrs[j], arrs[j+1]) > 0){
                    int temp = arrs[j];
                    arrs[j] = arrs[j+1];
                    arrs[j+1] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(arrs));
    }
}
~~~

~~~java
/**
 *  二分法查找binarySearch()/copyOf()/fill()/equals()/
 */
public class Arrays03 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 90, 123, 456};
        /*
            分析:
            1.binarySearch()通过二分法查找,要求必须排好序
            2.要求该数组必须是有序的,如果数组是无序的无法使用
            3.如果数组中不存在就返回 return -(low + 1) //key not found 含义就是: 找不到就在应该假设存在的位置上
         */
        int index1 = Arrays.binarySearch(arr, 2);
        System.out.println("index1 = " + index1);//1
        int index2 = Arrays.binarySearch(arr, 678);
        System.out.println("index2 = " +index2);//-6
        /*
            思考为啥是-6,查看源码
            return -(low + 1) //key not found 含义就是: 找不到就在应该假设存在的位置上
         */

        // copyOf() 数组元素的复制
        /*
            1.Arrays.copyOf(arr, arr.length):拷贝arr.length个元素到newArray中
            2.如果拷贝的长度 > arr.length 就在新数组的后面 增加 null
            3. 如果拷贝长度 < 0 就抛出异常 NegativeArraySizeException
            4. 该方法的底层使用的是 System.arraycopy()
         */

        Integer[] newArray = Arrays.copyOf(arr, 10);
        System.out.println(Arrays.toString(newArray)); //[1, 2, 90, 123, 456, null, null, null, null, null]

        // fill() 数组的填充
        /*
            1. 使用 99 去填充 num 数组，可以理解成是替换原来的元素
         */
        System.out.println("填充后");
        Arrays.fill(newArray,99);
        System.out.println(Arrays.toString(newArray));//[99, 99, 99, 99, 99, 99, 99, 99, 99, 99]

        // equals() 比较两个数组元素内容是否完全一致
        /*
            1. 如果 arr 和 arr2 数组的元素一样，则方法 true;
            2. 如果不是完全一样，就返回 false
        */
        Integer[] arr1 = {1, 2, 90, 123, 456};
        System.out.println(Arrays.equals(arr, arr1)); //true

        // asList() 将一个数组值,转换为list
        /*
            1.asList()，会将 (1, 2, 90, 123, 456) 数据转成一个 List 集合
            2.返回的 asList 编译类型 List(接口)
            3.asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的
                 静态内部类 private static class ArrayList<E> extendsAbstractList<E>
                 implements RandomAccess, java.io.Serializable
         */
        List<Integer> asList = Arrays.asList(arr);
        System.out.println("asList = " + asList);//asList = [1, 2, 90, 123, 456]
        System.out.println("asList的运行类型" + asList.getClass()); //asList的运行类型class java.util.Arrays$ArrayList
    }
}
~~~

#### 10.6.2 Arrays练习

~~~java
import java.util.Arrays;
import java.util.Comparator;

/**
 * 自定义 Book 类，里面包含 name 和 price，按 price排序(从大到小)。要求使用两种方式排序 , 有一个 Book[] books = 4 本书对象.
 * 使用前面学习过的传递 实现 Comparator 接口匿名内部类，也称为定制排序。
 * 可以按照 price (1)从大到小 (2)从小到大 (3) 按照书名长度从大到小
 * Book[] books = new Book[4];
 * books[0] = new Book("红楼梦", 100);
 * books[1] = new Book("金瓶梅新", 90);
 * books[2] = new Book("青年文摘20年", 5);
 * books[3] = new Book("java从入门到放弃~", 300);
 */
public class ArraysExercise01 {
    public static void main(String[] args) {
        Book[] books = new Book[4];
        books[0] = new Book("红楼梦", 100);
        books[1] = new Book("金瓶梅新", 90);
        books[2] = new Book("青年文摘20年", 5);
        books[3] = new Book("java从入门到放弃~", 300);

        //price (1)从大到小
        Arrays.sort(books, new Comparator(){
            @Override
            public int compare(Object o1, Object o2) {
                //这里如果是对Book[]排序,因此这里的o1 与 o2就是Book对象
                Book b1 = (Book)o1;
                Book b2 = (Book)o2;
                //这里针对返回值为double做了转换处理
                double priceOf = b1.getPrice() - b2.getPrice();
                //这里如果与我们的需求不一致就需要调整返回值进行处理
                if (priceOf > 0){
                    return -1;
                }else if (priceOf < 0){
                    return 1;
                }else {
                    return 0;
                }
            }
        });
        System.out.println(Arrays.toString(books));//此处需要将Book的toString()重写
    }
}



class Book {

    private String name;
    private double price;

    public Book(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}
~~~

### 10.7 System类

#### 10.7.1 System类常见的方法和案例

> 1) exit(): 退出当前程序
>
> 2) arraycopy(): 复制数组元素,比较适合底层调用,一般使用Arrays.copyOf()完成数组复制
>
> ​	int[] src = {1, 2, 3};
>
> ​	int[] dest = new int[3];
>
> ​	System.arraycopy(src, 0, dest, 0, 3);
>
> 3) currentTimeMillis(): 返回当前时间距离1970-1-1的毫秒数
>
> 4) gc(): 运行垃圾回收机制,System.gc();

~~~java
import java.util.Arrays;

/**
 * System方法
 */
public class System01 {
    public static void main(String[] args) {

        //1.exit() 退出当前程序
        /*
            1.exit(0):表示程序退出的状态
            2.0表示状态:正常状态
         */
        System.out.println("程序开始");
//        System.exit(0);
        System.out.println("程序退出");

        //2.arraycopy() 复制数组元素,比较适合底层调用,一般使用Arrays.copyOf()完成数组复制
        int[] src = {1, 2, 3};
        int[] dest = new int[3];
        /*
            1.主要搞清楚这5个参数的含义
                     @param     src         the source array.  源数组
                     @param     srcPos      starting position in the source array.  从源数组的哪个索引位置开始拷贝
                     @param     dest        the destination array.  目标数组
                     @param     destPos     starting position in the destination data.  把源数组的数据拷贝到 目标数组的哪个索引
                     @param     length      the number of array elements to be copied.  从源数组拷贝多少个数据到目标数组
         */
        System.arraycopy(src, 0, dest, 0, 3);
        System.out.println(Arrays.toString(dest));//[1,2,3]

        // 3.currentTimeMillis():返回当前时间距离 1970-1-1 的毫秒数
        System.out.println(System.currentTimeMillis());//1651674503268
    }
}
~~~

### 10.8 大数处理方案

#### 10.8.1 BigInteger 和 BigDecimal类

> 应用场景:
>
> 1) BigInteger适用于保存比较大的整型
>
> 2) BigDecimal适用于保存精度更高的浮点型(小数)

~~~java
import java.math.BigDecimal;
/**
 *  演示 BigInteger类
 */
public class BigNum01 {
    public static void main(String[] args) {

//        long l = 3215644878999999999999999L; // 过大的整数
//        System.out.println("l=" + l);

        //当我们处理很大的整数时,long无法使用,可以使用BigInteger类
        BigInteger bigInteger = new BigInteger("3215644878999999999999999");
        System.out.println(bigInteger);//3215644878999999999999999
        /*
            1.在对BigInteger进行 加减乘除的时候,需要使用对应的方法,不能直接进行
            2.加减乘除的结果不会直接影响原数据
         */
//        System.out.println(bigInteger + 1);//运算符 '+' 不能应用于 'java.math.BigInteger'、'int'

        //加
        BigInteger bigInteger1 = new BigInteger("200");
        System.out.println(bigInteger.add(bigInteger1));//3215644879000000000000199
        //减
        System.out.println(bigInteger.subtract(bigInteger1));//3215644878999999999999799
        //乘
        System.out.println(bigInteger.multiply(bigInteger1));//643128975799999999999999800
        //除
        System.out.println(bigInteger.divide(bigInteger1));//16078224394999999999999
    }
}
~~~

~~~java
import java.math.BigDecimal;

/**
 *  演示 BigDecimal类
 */
public class BigNum02 {
    public static void main(String[] args) {

        double d  = 548989496816.131454848489516234514524523451d;
        System.out.println(d); //5.489894968161315E11

        //当我们需要保存一个精度很高的数时,精度不够用了,使用BigDecimal类
        BigDecimal bigDecimal = new BigDecimal("548989496816.131454848489516234514524523451");
        System.out.println(bigDecimal);//548989496816.131454848489516234514524523451
        /*
            1.如果对BigDecimal进行运算,加减乘除,也是需要使用对应的方法
            2.创建一个需要操作的BigDecimal然后调用相应的方法即可
         */
//        System.out.println(bigDecimal + 1);//运算符 '+' 不能应用于 'java.math.BigDecimal'、'int'
        BigDecimal bigDecimal1 = new BigDecimal("1.1111111111111111111");
        //加
        System.out.println(bigDecimal.add(bigDecimal1));//548989496817.242565959600627345614524523451

        //减
        System.out.println(bigDecimal.subtract(bigDecimal1));//548989496815.020343737378405123414524523451

        //乘
        System.out.println(bigDecimal.multiply(bigDecimal1));//609988329795.7016164922218014070591221944067831529498386164061

        //除 可能会出现异常(ArithmeticException),因为除不尽的情况下,就会出现无限循环小数,怎么解决呢?-----在调用divide()时,指定精度即可 BigDecimal.ROUND_CEILING
        // 如果有无限循环小数,就会保留"分子"的精度
        System.out.println(bigDecimal.divide(bigDecimal1,BigDecimal.ROUND_CEILING));//java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
        //494090547134.518309368581470082408255164792
    }
}
~~~

### 10.9 日期类

#### 10.9.1 第一代日期类

> 说明:
>
> 1) Data类,精确到豪秒,代表特定的瞬间
>
> 2) SimpleDateFarmat类,格式化和解析日期的具体类,它允许进行格式化(日期 -> 文本);解析 (文本 -> 日期)和规范化

~~~java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 *  Date类介绍
 */
public class Date01 {
    public static void main(String[] args) throws ParseException {
        /*
            1.获取当前系统时间
            2.java.util.Date,不能引入java.sql.date
            3.默认输出的日期格式为国外的方式,所以通常进行格式转换 SimpleDateFormat
         */
        Date date = new Date();//获取当前系统时间
        System.out.println(date);//Wed May 04 23:23:34 CST 2022
        // 创建SimpleDateFormat对象,可以指定相应的格式
        //相应的格式,是规定好的,不能乱写
        /*
            y  Year  Year  1996; 96
            Y  Week year  Year  2009; 09
            M  Month in year (context sensitive)  Month  July; Jul; 07
            L  Month in year (standalone form)  Month  July; Jul; 07
            w  Week in year  Number  27
            W  Week in month  Number  2
            D  Day in year  Number  189
            d  Day in month  Number  10
            F  Day of week in month  Number  2
            E  Day name in week  Text  Tuesday; Tue
            u  Day number of week (1 = Monday, ..., 7 = Sunday)  Number  1
            a  Am/pm marker  Text  PM
            H  Hour in day (0-23)  Number  0
            k  Hour in day (1-24)  Number  24
            K  Hour in am/pm (0-11)  Number  0
            h  Hour in am/pm (1-12)  Number  12
            m  Minute in hour  Number  30
            s  Second in minute  Number  55
            S  Millisecond  Number  978
            z  Time zone  General time zone  Pacific Standard Time; PST; GMT-08:00
            Z  Time zone  RFC 822 time zone  -0800
            X  Time zone  ISO 8601 time zone  -08; -0800; -08:00
         */
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss E");
        String format = simpleDateFormat.format(date);
        System.out.println(format);//2022年05月04日 11:47:42 星期三

        //4.通过指定毫秒数得到时间
        Date date1 = new Date(123456789);
        System.out.println(date1);//Fri Jan 02 18:17:36 CST 1970
        System.out.println(simpleDateFormat.format(date1));//1970年01月02日 06:17:36 星期五
        //5.获取某个时间对应的毫秒数
        System.out.println(date.getTime());//1651679219790

        //6.可以把一个格式化的字符串,转成对应的Date,得到的Date输出时还是按照国外的形式,如果希望指定格式输出,需要转换
        //注意:这个String -> Date,使用的simpleDateFormat格式需要和你给的String的格式一样,否则会抛出转换异常
        String s = "2022年05月04 11:47:42 星期三";
        Date parse = simpleDateFormat.parse(s);
        System.out.println(parse);//Wed May 04 11:47:42 CST 2022
        //ParseException: Unparseable date: "2022年05月04 11:47:42 星期三"
    }
}
~~~

#### 10.9.2 第二代日期类

> 1) 第二代日期类,主要就是Calendar类(日历)
>
> ​	public abstract class Calendar implements Serializable, Cloneable, Comparable<Calendar> {...}
>
> 2) Calendar类是一个抽象类,它为特定瞬间与一组如YEAR, MONTH, DAY_OF_MONTH HOUR等日历字段之间的转换提供了一些方法,并为操作日历字段(例如获取下星期的日期)提供了一些方法

~~~java
import java.util.Calendar;

/**
 *  Calendar类介绍及方法
 */
public class Date02 {
    public static void main(String[] args) {
        /*
            1.Calendar是抽象类,并且构造器是protected
            2.可以通过getInstance() 来获取实例
            3.提供了大量的方法和字段来使用
         */
//        Calendar calendar = new Calendar(); //'Calendar' 为 abstract；无法实例化
        Calendar calendar = Calendar.getInstance();
        System.out.println("calendar=" + calendar);// 可以看出对象有如下字段信息
        //calendar=java.util.GregorianCalendar[time=1651789017510,
        // areFieldsSet=true,areAllFieldsSet=true,lenient=true,
        // zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",
        // offset=28800000,dstSavings=0,useDaylight=false,
        // transitions=19,lastRule=null],firstDayOfWeek=1,
        // minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,
        // MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=1,DAY_OF_MONTH=6,
        // DAY_OF_YEAR=126,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=1,
        // AM_PM=0,HOUR=6,HOUR_OF_DAY=6,MINUTE=16,SECOND=57,
        // MILLISECOND=510,ZONE_OFFSET=28800000,DST_OFFSET=0]

        //4.获取日历对象的某个字段
        /*
            Calendar.YEAR: 表示Calendar类某个字段,通过 实例.get() --面向对象的思想
         */
        System.out.println("年" + calendar.get(Calendar.YEAR));

        /*
            这里为什么要加1,因为Calendar返回月份的时候,是按照0开始编号的
         */
        System.out.println("月" + calendar.get(Calendar.MONTH) + 1) ;
        System.out.println("日" + calendar.get(Calendar.DAY_OF_MONTH));
        System.out.println("时" + calendar.get(Calendar.HOUR));
        System.out.println("分" + calendar.get(Calendar.MINUTE));
        System.out.println("秒" + calendar.get(Calendar.SECOND));

        //5.Calendar没有专门的格式化方法，所以需要程序员自己来组合显示
        System.out.println(calendar.get(Calendar.YEAR) + "年" + (calendar.get(Calendar.MONTH) + 1) + "月" +
                        calendar.get(Calendar.DAY_OF_MONTH) + "日" +
                        calendar.get(Calendar.HOUR) + "时" +
                        calendar.get(Calendar.MINUTE) + "分" +
                        calendar.get(Calendar.SECOND) + "秒"
                );
        
        //6.如果需要按照24小时来暂时时间
        System.out.println(calendar.get(Calendar.HOUR_OF_DAY));

    }
}
~~~

#### 10.9.3 第三代日期类

> 前面两代日期的不足分析:
>
> Date类自JDK1.1引入Calendar类后被弃用了,但是Calendar类也存在问题:
>
> 1)可变性: 像日期和时间这样的类应该是不可变的;
>
> 2)偏移性: Date中的年份是从1900年开始,而月份都是从0开始;
>
> 3)格式化:格式化只对Date类有效,Calendar则不行
>
> 4)此外,他们也是线程不安全的,不能处理闰秒等(每隔2天,多出1s)



> jdk8引入时间: LocalDate(日期), LocalTime(时间), LocalDateTime(日期时间)
>
> 说明:
>
> LocalDate只包含日期,可以获取日期字段(年/月/日)
>
> LocalTime只包含时间,可以获取时间字段(时/分/秒)
>
> LocalDateTime包含日期 + 时间,可以获取日期和时间字段(年/月/日/时/分/秒)



> 格式化日期类,类似于SimpleDateFormat
>
> LocalDateTime ldt = LocalDateTime.now();
>
> DateTimeFormat dtf = DateTimeFormat.ofPattern("yyyy年MM月dd日 HH时mm分ss秒")
>
> String str = dtf.format(ldt);

~~~java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 *  LocalDate/LocalTime/LocalDateTime 的方法使用
 */
public class Date03 {
    public static void main(String[] args) {
        //1.使用now()可以返回当前日期时间的对象
        LocalDateTime localDateTime = LocalDateTime.now();//LocalDate.now(); localTime.now()
        System.out.println(localDateTime);//2022-05-06T06:58:41.668
        System.out.println("年" + localDateTime.getYear());
        System.out.println("月" + localDateTime.getMonth());
        System.out.println("月" + localDateTime.getMonthValue());//MAY
        System.out.println("日" + localDateTime.getDayOfMonth());//5
        System.out.println("时" + localDateTime.getHour());
        System.out.println("分" + localDateTime.getMinute());
        System.out.println("秒" + localDateTime.getSecond());
        //LocalDate.now(); localTime.now() 用法类似,不同的是获取的字段不一样

        //2.格式日期类: 使用DateTimeFormat对象来进行格式化
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String format = dateTimeFormatter.format(localDateTime);
        System.out.println("格式化的日期" + format);
    }
}
~~~

> 时间戳 Instant ,类似于Date
>
> Instant --> Date : Date date = Date.from(instance);
>
> Date --> Instant: Instant instant = Date.toInstant();

~~~java
/**
 *  日期类的时间戳 : Instant
 */
public class Date04 {
    public static void main(String[] args) {

        //1.通过静态方法now() 表示当前时间的时间戳对象
        Instant now = Instant.now();
        System.out.println(now);//2022-05-05T23:24:35.755Z
        //2.通过Date.from()可以把Instance转换成Date
        Date date = Date.from(now);
        System.out.println(date);//Fri May 06 07:27:16 CST 2022
        //3.将Date转换为Instant,通过Date.toInstant()进行转换
        Instant instant = date.toInstant();
        System.out.println(instant);//2022-05-05T23:30:57.364Z
    }
}
~~~

> 第三代日期类更多方法
>
> LocalDateTime类
>
> MonthDay类:检查重复事件
>
> 是否闰年
>
> 增加日期的某个部分
>
> 使用plus() 测试增加时间的某个部分
>
> 使用minus() 测试查看一年前和一年后的日期

~~~java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 *  plus() 和 minus()
 */
public class Date05 {
    public static void main(String[] args) {
        LocalDateTime localDateTime = LocalDateTime.now();
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        //1.提供plus和minus方法可以对当前时间进行加或者减
        //增加890天时什么日期
        LocalDateTime localDateTime1 = localDateTime.plusDays(890);
        System.out.println(dateTimeFormatter.format(localDateTime1));//2024-10-12 08:05:15

        //减去3456分钟前是什么时候
        LocalDateTime localDateTime2 = localDateTime.minusMinutes(3456);
        System.out.println(dateTimeFormatter.format(localDateTime2));//2022-05-03 22:30:36

    }
}
~~~

### 10.10 本章作业

~~~java
/**
 *  编程题:
 *  1.将字符串中指定部分进行反转,比如将"abcdef"反转为"aedcbf"
 *  2.编写方法 public static String reverse(String str, int start, int end)
 */
public class HomeWork01_teacher {
    /*
        思路分析:
        1.先定义方法
        2.把String转换为char[],因为char[]的元素是可以交换的
        3.画出分析示意图:i向右移动,j向左移动,每移动一次,i与j进行交换,直到 i > j 停止交换,当然i=j就不考虑交换没意义
        4.代码实现
     */
    public static void main(String[] args) {
        String str = "abcdef";
        int start = str.indexOf("b");
        int end = str.indexOf("e");
        try {
            str = reverse(str, 1, 100);
        } catch (Exception e) {
            System.out.println(e.getMessage());
            return;
        }
    }

    public static String reverse(String str, int start, int end){
        //对输入的参数做校验
        //这里有重要的编程技巧:因为不正确的条件比较发散
        //1.先写出正确的输入条件;
        //2.然后取反即可
        if (!(str != null && start >=0 && end > start && end < str.length())){
            throw new RuntimeException("参数不正确");
        }
        char[] chars = str.toCharArray();
        char temp = ' ';
        for (int i = start, j = end; i < j; i++, j--){
            temp = chars[i];
            chars[i] = chars[j];
            chars[j] = temp;
        }
        //使用chars[]重写构建一个String
        return new String(chars);
    }
}
~~~

~~~java
/**
 *  编程题:
 *  输入用户名、密码、邮箱，如果信息录入正确，则提示注册成功，否则生成异常对象，要求：
 *  1.用户名长度为2或者3或者4
 *  2.密码的长度为6，要求全为数字（isDigit）
 *  3.邮箱中包含@和. 并且@在.之前
 */
public class HomeWork02_teacher {
    /*
        分析:
        1.先编写方法userRegister(String name, String passwd, String email)
        2.针对输入的内容进行校验,就抛出异常给出提示
        3.单独写一个方法,来判断密码是否全部是数字,返回boolean
     */
    public static void main(String[] args) {
        String name = "jack";
        String pwd = "123456";
        String email = "123@sk.com";

        try {
            userRegister(name, pwd, email);
            System.out.println("注册成功");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    public static void userRegister(String name, String passwd, String email){
        int userLength = name.length();
        if (!(userLength >=2 && userLength <= 4)){
            throw new RuntimeException("用户名长度为2或者3或者4");
        }

        if (!(passwd.length() == 6 && isDigit(passwd))){
            throw new RuntimeException("密码的长度为6，要求全为数字");
        }

        int i = email.indexOf("@");
        int j = email.indexOf(".");
        // i >0 ,j > i ---> j>0(存在i), j>i(. > @)
        if (!(i > 0 || j > i)){
            throw new RuntimeException("邮箱中包含@和. 并且@在.之前");
        }
    }

    public static boolean isDigit(String str){
        char[] chars = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            //字符有在非'0' - '9'之间,说明不是纯数字
            if (chars[i] < '0' || chars[i] > '9'){
                return false;
            }
        }
        //执行到这里,说明是纯数字
        return true;
    }


}

~~~

~~~java
/**
 *  编程题:
 *  1.编写java程序,输入形式为: Han shun Ping的人名,以Ping,Han.S的形式打印出来,其中.S是中间单词的首字母
 *  2.例如输入"Willian jefferson Clinton",输出形式为: Clinton,Willian .J
 */
public class HomeWork03_teacher {
    /*
        分析:
        1.使用split() 进行分割
        2.对得到的String[] 进行格式化String.format()
        3.对输入的字符串进行校验即可
     */
    public static void main(String[] args) {
        String name = "Willian jefferson Clinton";
        printName(name);
    }

    public static void  printName(String name){

        if (name == null){
            System.out.println("name不能为空");
            return;
        }
        String[] str = name.split(" ");
        if (str.length != 3){
            System.out.println("输入的字符串格式不正确");
            return;
        }
        String format = String.format("%s,%s .%c", str[2], str[0], str[1].toUpperCase().charAt(0));
        System.out.println(format);
    }
}
~~~

~~~java
/**
 *  编程题:
 *  输入字符串,判断里面有多少个大写字母,多少个小写字母,多少个数字
 */
public class HomeWork04 {
    public static void main(String[] args) {
        String s = "ajsdhf12635467HEUYQRLQWE";
        decide(s);
    }

    public static void decide(String str){

        if (str == null){
            throw new RuntimeException("String 不合法");
        }
        char[] chars = str.toCharArray();
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] >= 'A' && chars[i] <= 'Z'){
                num1++;
            }else if (chars[i] >= 'a' && chars[i] <= 'z'){
                num2++;
            }else if (chars[i] >= '0' && chars[i] <= '9'){
                num3++;
            }else {
                
            }
        }
        System.out.println(num1 + "个大写字母");
        System.out.println(num2 + "个小写字母");
        System.out.println(num3 + "个数字");
    }
}
~~~
